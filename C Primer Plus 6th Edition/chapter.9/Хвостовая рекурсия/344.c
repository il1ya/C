/*
рассмотрим версии с циклом и хвостовой рекурсией для функции вычисления факториала. 
Факториал целого числа — это результат произведения всех целых чисел, начиная с 1 и заканчивая заданным числом. 
Например, факториал 3 (записывается как 3!) соответствует произведению 1*2*3. Кроме того, О! принимается равным 1, а для отрицательных чисел факториалы не определены. 
В листинге 9.7(factor.c) в одной фуркции для вычисления факториала применяется цикл for, а во второй функции — рекурсия.
*/
// factor.c -- использует циклы и рекурсию для вычисления факториалов
#include <stdio.h>
long fact(int n);
long rfact(int n);
int main(void)
{
	int num;
	printf("This program calculates factorials.\r\n"); // Эта программа вычисляет факториалы
	printf("Enter a value in the range 0-12(q to quit):\r\n"); // Введите значение в диапазоне 0-12(q для завершения)
	while(scanf("%d", &num) == 1)
	{
		if(num < 0)
			printf("No negative numbers, please.\r\n"); // Отрицательные числа не подходят
		else if(num > 12)
			printf("Keep input under 13.\r\n"); // Вводимое значение должно быть меньше 13
		else
		{
			printf("Loop: %d factorial = %ld\r\n", num, fact(num)); // цикл: факториал
			printf("recursion: %d factorial = %ld\r\n", num, rfact(num)); // рекрсия: факториал
		}
		printf("Enter a value in the range 0-12 (q to quit):\r\n"); // Введите значение в диапазоне 0-12(q для завершения)
	}
	printf("Bye.\r\n");
	return 0;
}
// функция, основанная на цикле инициализирует переменную ans значением 1, а затем умножает ее на целые числа от n до 2. 
// Формально следовало бы умножить также и на 1, но результат от этого не изменится.
long fact(int n) // функция, основанная на цикле
{
	long ans;
	for(ans = 1; n > 1; n--)
		ans *= n;
	return ans;
}
long rfact(int n) // рекурсивная версия
{
	long ans;
	if(n > 0)
		ans = n * rfact(n - 1);
	else
		ans = 1;
	return ans;
}
/*
Рекурсивная версия программы в листинге 9.7(factor.c) дает тот же самый результат, что и версия с циклом. 
Обратите внимание, что хотя вызов rfact() не является последней строкой в функции, это последний оператор, выполняемый, когда n > О, т.е. мы имеем дело с хвостовой рекурсией.
Учитывая возможность применения в коде функции либо цикла, либо рекурсии, какому подходу должно отдаваться предпочтение? 
Обычно цикл является более удачным выбором. Во-первых, из-за того, что каждый рекурсивный вызов создает собственный
набор переменных, вариант с рекурсией использует больше памяти; каждый рекурсивный вызов помещает в стек новый набор переменных. 
При этом ограниченный объем стека может устанавливать предел количества рекурсивных вызовов. 
Во-вторых, рекурсия выполняется медленнее, т.к. каждый вызов функции занимает определенное время. 
Для чего тогда демонстрировался этот пример? Причина в том, что хвостовая рекурсия является самой простой формой рекурсии для ее понимания, а рекурсия
заслуживает освоения, поскольку в ряде случаев простая альтернатива в виде цикла отсутствует.
*/