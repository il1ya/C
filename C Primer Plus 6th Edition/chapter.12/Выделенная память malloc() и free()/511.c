/*
double * ptd;
ptd = (double *) malloc(3O * sizeof(double));
Обычно вы должны компенсировать каждый случай вызова malloc() вызовом free(). 
Функция free() принимает в качестве артумента адрес, возвращенный ранее функцией malloc(), и освобождает память, которая была выделена.
Таким образом, продолжительность существования выделенной памяти рассчитывается с момента, когда была вызвана функция malloc() для выделения памяти, 
и до момента, когда вызывается функция free() с целью освобождения памяти для ее повторного использования.
Функции malloc() и free() можно рассматривать как инструменты для управления пулом памяти. 
Каждый вызов malloc() выделяет память для применения программой, а каждый вызов free() восстанавливает память в пуле, так что она может повторно использоваться. 
Аргументом free() должен быть указатель на блок памяти, выделенный malloc(); функцию free() нельзя применять для освобождения
памяти, выделенной другими средствами, такими как объявление массива. 
Функции malloc() и free() имеют прототипы в заголовочном файле stdlib.h.
За счет использования malloc() программа может решать, массив какого размера требуется, и создавать его во время выполнения. 
Эта возможность демонстрируется в листинге 12.14. В нем указателю ptd присваивается адрес блока памяти, после чего ptd применяется, как если бы это было имя массива. 
Если выделить нужную память не удаяось, для прекращения работы программы вызывается функция exit() , прототип которой содержится в stdlib.h. 
Значение EXIT_FAILURE определено в этом же заголовочном файле. 
Стандарт предоставляет два возвращаемых значения, которые гарантированно распознают все операционные системы: 
EXIT_SUCCESS (эквивалентно значению О) для указания на нормальное завершение программы и EXIT_FAILURE для указания на аварийное завершение. 
Некоторые операционные системы, валючая Unix, Linux и Windows, могут принимать дополнительные целочисленные значения, обозначающие конкретные формы отказа.*/
// Листинг 12.14. Программа dyn_arr.c
/*dyn_arr.c -- динамически выделяемый массив*/
#include <stdio.h>
#include <stdlib.h> /*для malloc(), free()*/

int main(void)
{
	double *ptd;
	int max = 0;
	int number;
	int i = 0;

	puts("What is the maximum number of type double entries?"); // Введите максимальное количество элементов типа double.
	if(scanf("%d", &max) != 1)
	{
		puts("Number not correctly entered -- bye"); // Количество введенно некорректно -- программа завершена.
		exit(EXIT_FAILURE);
	}
	ptd = (double *) malloc(max * sizeof(double));
	if(ptd == NULL)
	{
		puts("Memory allocation failed. Goodbye."); // Не удалось выделить память. Программа завершена.
		exit(EXIT_FAILURE);
	}
	/*ptd теперь указывает на массив из max элементов*/
	puts("Enter the values (q to quit):"); // Введите значения (q для выхода)
	while(i < max && scanf("%lf", &ptd[i]) == 1)
		++i;
	printf("Here are your %d entries:\r\n", number = i); // Введено элементов:
	for(i = 0; i < number; i++)
	{
		printf("%7.2f ", ptd[i]);
		if(i % 7 == 6)
			putchar('\n');
	}
	if(i % 7 != 0)
		putchar('\n');
	puts("Done.");
	free(ptd);
	return 0;
}
/*Давайте рассмотрим код. Программа получает нужный размер массива с помощью следующих строк:
	if(scanf("%d", &max) != 1)
	{
		puts("Number not correctly entered -- bye"); // Количество введенно некорректно -- программа завершена.
		exit(EXIT_FAILURE);
	}
Показанная ниже строка кода выделяет в памяти пространство, достаточное для
хранения запрошенного количества элементов, и затем присваивает адрес этого блока указателю ptd:
ptd = (double *) malloc(max * sizeof(double));
Приведение к (double *) не обязательно в С, но требуется в C++, поэтому использование приведения типа упрощает перенос программы из С в C++.
Вполне вероятно, что функция malloc() не сможет предоставить желаемый объем памяти. В этом случае она возвращает нулевой указатель, и выполнение программы прекращается:
	if(ptd == NULL)
	{
		puts("Memory allocation failed. Goodbye."); // Не удалось выделить память. Программа завершена.
		exit(EXIT_FAILURE);
	}
Если программа преодолеет это препятствие, она может трактовать ptd, как если бы оно было именем массива из max элементов, что и делается.
Обратите внимание на вызов функции free() ближе к концу программы. Она освобождает память, выделенную malloc().
Функция free() освобождает только блок памяти, на который указывает ее аргумент. 
Некоторые операционные системы будут освобождать выделенную память автоматически при завершении программы, но другие могут этого не делать. 
Таким образом, применяйте free() и не полагайтесь на то, что операционная система выполнит очистку вместо вас.*/
/*Какую пользу мы извлекли из того, что воспользовались динамическим массивом?
В этом случае мы увеличили гибкость программы. 
Предположим, вы знаете, что большую часть времени программе будет требоваться не более 100 элементов, но иногда она будет нуждаться в 10 ООО элементов. 
Если вы объявляете массив, то должны учитывать худший случай и объявить его с 10 ООО элементов. 
Большую часть времени программа будет расходовать память понапрасну. 
К тому же, если наступит момент, когда понадобится иметь 10 001 элемент, программа потерпит отказ.
Применение динамического массива позволяет программе подстраиваться под существующие обстоятельства.*/