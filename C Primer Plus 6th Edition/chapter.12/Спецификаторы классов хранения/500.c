// Листинг 12.6. Программа partb.c
// partb.c -- остальная часть программы
// компилировать вместе с parta.c
#include <stdio.h>
extern int count; // ссылочное объявление, внешнее связывание
static int total = 0; // статическое определение, внутренне связывание
void accumulate(int k); // прототип
void accumulate(int k) // k имеет область видимости в пределах блока, связывание отсутствует
{
	static int subtotal = 0; // статическая переменная, связывание отсутсвует
	if(k <= 0)
	{
		printf("loop cycle: %d\r\n", count); // итерация цикла:
		printf("subtotal: %d; total: %d\r\n", subtotal, total);
		subtotal = 0;
	}
	else
	{
		subtotal += k;
		total += k;
	}
}
/*В этой программе статическая переменная с областью видимости в пределах блока, имеющая имя suЬtotal, накапливает промежуточную сумму значений, передаваемых
функции accumulate(), а переменная total с областью видимости в пределах файла и внутренним связыванием наращивает общую сумму. 
Функция accumulate() выводит значения total и subtotal каждый раз, когда ей передается неположительное значение; 
в таких ситуациях она также сбрасывает subtotal в О. Прототип accumulate() в программе parta.с обязателен, т.к. файл содержит вызов функции accumulate(). 
В файле partb.с прототип не обязателен, поскольку функция в нем определена, но не вызывается. 
В этой функции также применяется внешняя переменная count для отслеживания количества итераций цикла while, выполненных в main(). 
(Кстати, это хороший пример того, как не следует использовать внешнюю переменную, потому что она нежелательным образом переплетает код в parta.с с кодом в partb.с.) 
В файле parta.с функции main() и report_count() совместно осуществляют доступ к count.*/