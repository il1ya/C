/*Теперь, когда вы получили необходимый минимум знаний о классах хранения, давайте рассмотрим пару программ, в которых они применяются. 
Первым делом мы взглянем на функцию, которая использует статическую переменную с внутренним связыванием: функцию генерации случайных чисел. 
Для генерации случайных чисел библиотека ANSI С предлагает функцию rand(). 
Существуют разнообразные алгоритмы генерации случайных чисел, и ANSI С позволяет реализациям выбирать наилучший алгоритм для конкретной машины. 
Однако ANSI С также предлагает стандартный переносимый алгоритм, который выдает те же самые случайные числа в разных системах.
В действительности функция rand() является "генератором псевдослучайных чисел", 
т.е. фактическая последовательность чисел предсказуема, но числа достаточно равномерно распределены по диапазону возможных значений.
Вместо применения встроенной функции rand() компилятора, мы будем использовать переносимую версию ANSI, чтобы вы могли видеть, что происходят внутри.
Схема начинается с числа, которое называется “начальным”. Функция применяет начальное число для получения нового числа, которое становится новым начальным числом. 
Затем новое начальное число может использоваться для получения следующего нового начального числа и т.д. 
Чтобы эта схема работала, функция генерации случайных чисел должна запоминать начальное число, которое применялось при ее последнем вызове. 
Здесь и возникает потребность в статической переменной. В листинге 12.7 представлена версия О (вскоре появится и версия 1).*/
/* rand0.c -- генерация случайных чисел*/
/* используется переносимый алгоритм ANSI C*/
static unsigned long int next = 1; /*начальное число*/
int rand0(void)
{
/*	магическая формула генерации псевдослучайных чисел*/
	next = next * 1103515245 + 12345;
	return (unsigned int) (next / 65536) % 32768;
}
/*В листинге 12.7 статическая переменная next начинает со значения 1 и изменяется магической формулой при каждом вызове функций. 
Результатом будет возвращаемое значение, находящееся где-то в диапазоне от О до 32767. 
Обратите внимание, что next является статической переменной с внутренним связыванием, а не просто статической переменной без связывания. 
Дело в том, что позже пример будет расширен, чтобы переменная next совместно использовалась двумя функциями в том же самом файле.*/