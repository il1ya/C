/*Название статическая переменная звучит как взаимоисключающее, вроде переменной, которая не может быть изменена. 
В действительности характеристика статическая означает, что переменная остается помещенной в память, а не обязательно относится к значению. 
Переменные с областью видимостью в пределах файла автоматически (и обязательно) имеют статическую продолжительность хранения.
Как упоминалось ранее, можно также создавать локальные переменные, имеющие область видимости в пределах блока, но статистическую продолжительность хранения. 
Такие переменные обладают такой же областью видимости, как автоматические переменные, однако они не исчезают, когда содержащая их функция завершает свою работу.
Другими словами, такие переменные имеют область видимости в пределах блока, не имеют связывания, но имеют статическую продолжительность хранения. 
Компьютер помнит их значения от одного вызова функции до следующего. 
Такие переменные создаются в результате объявления в блоке (что обеспечивает область видимости в пределах блока и отсутствие связывания) 
со спецификатором класса хранения static (предоставляющим статическую продолжительность хранения).
Пример в листинге 12.3 служит иллюстрацией этого приема.*/
// Листинг 12.3. Программа loc_stat.c
// loc_stat.c -- использование локальной статической переменной
#include <stdio.h>
void trystat(void);
int main(void)
{
	int count; // переменная count объявлена, по умолчанию является автоматической
	for(count = 1; count <= 3; count++)
	{
		printf("Here comes iteration %d:\r\n", count); // Начинается итерация
		trystat();
	}
	return 0;
}
// инкрементирует каждую переменную после вывода ее значения.
void trystat(void)
{
	int fade = 1;
	static int stay = 1; // Статическая переменная stay
	printf("fade = %d and stay = %d\r\n", fade++, stay++);
}

Статическая переменная stay запоминает, что ее значение было увеличено на 1, но переменная fade каждый раз начинается заново. 
Это отражает отличие в инициализации:
fade инициализируется при каждом вызове trystat(), а stay — только один раз, когда функция trystat() компилируется. 
Статические переменные инициализируются нулем, если они были явно инициализированы другим значением.
Два следующих объявления выглядят похожими:
int fade = 1;
static int stay = 1;
Тем не менее, первый оператор в действительности является частью функции trystat() и выполняется каждый раз, когда функция вызвана. 
Это действие времени выполнения. Второй оператор на самом деле не относится к функции trystat().
Если вы примените отладчик для пошагового выполнения программы, то увидите, что программа как бы пропускает этот шаг. 
Причина в том, что после того, как программа загрузилась в память, статические переменные и внешние переменные уже находятся в нужных местах. 
Помещение оператора объявления в функцию trystat() сообщает компилятору, что только функции trystat() разрешено видеть данную переменную;
это не оператор, который исполняется во время выполнения.
Использовать модификатор static для параметров функции нельзя:
int wontwork(static int flu); // не разрешено
Другим термином для статической переменной с областью видимости в пределах блока является "локальная статическая переменная". 
Кроме того, если вы читали раннюю литературу по С, то обнаружите, что этот класс хранения называли внутренним
статическим классом хранения. Тем не менее, слово внутренний применялось для указания на объявление внутри функции, а не на внутреннее связывание.