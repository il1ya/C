/*Программа, в которой применяется функция roll_n_dice(), должна включать указанный заголовочный файл. 
Это не только предоставляет прототип функции roll_n_dice(), но также делает доступной переменную roll_count в программе.
Все сказанное иллюстрируется в листинге 12.13.*/
// Листинг 12.13. Файл manydice.c
/*manydice.c -- бросание множества костей*/
/*компилировать вместе с diceroll.c*/
#include <stdio.h>
#include <stdlib.h> 	/*для библиотечной функции srand()*/
#include <time.h> 		/*для функции time()*/
#include "diceroll.h" 	/*для функции roll_n_dice()*/
						/*и для переменной roll_count*/
int main(void)
{
	int dice, roll;
	int sides, status;

	srand((unsigned int) time(0)); /*рандомизация начального числа*/
	printf("Enter the number of sides per die, 0 to stop.\r\n"); // введите количество граней кости или 0 для завершения программы.
	while(scanf("%d", &sides) == 1 && sides > 0)
	{
		printf("How many dice?\r\n"); // сколько костей?
		if((status = scanf("%d", &dice)) != 1)
		{
			if(status == EOF)
				break;  /*выход из цикла*/
				else
				{
			printf("You should have entered an integer."); // Вы должны ввести целое число.
			printf(" Let's begin again.\r\n"); // Давайте начнем с начала.
			while(getchar() != '\n')
				continue; /*отбросить некорректный ввод*/
			printf("How many sides? Enter 0 to stop.\r\n"); // Сколько граней? Для прекращения введите.
				continue; /*новая итерация цикла*/
				}
		}
		roll = roll_n_dice(dice, sides);
		printf("You have rolled a %d using %d %d-sided dice.\r\n", roll, dice, sides); // Вы бросали раз(а), используя кости с гранями
		printf("How many sides? Enter 0 to stop.\r\n"); // Сколько граней? Для прекращения введите 0.
	}
	printf("The rollem() function was called %d times.\r\n", roll_count); // функция rollem() была вызвана раз
	printf("GOOD FORTUNE TO YOU!\r\n"); // Пусть удача не покидает вас!
	return 0;
}
/*Скомпилируйте файл с кодом из листинга 12.13 вместе с файлом, содержащим код из листинга 12.11. 
Для простоты поместите файлы с исходным кодом из листингов 12.11, 12.12 и 12.13 в одну и ту ж е папку или каталог. Запустите результирующую программу.*/
/*Из-за того, что в программе используется функция srand() для рандомизации начального слушйного числа, скорее всего, вы не получите один и тот ж е вывод при том же самом входном значении. 
Обратите внимание, что функция main() в manydice.с имеет доступ к переменной roll_count, определенной в diceroll.c.
Внешний цикл while может прекратиться по трем причинам: значение sides оказывается меньше 1, введенное значение не соответствует по типу 
(scanf () возвращает О) или встретился конец файла (scanf() возвращает EOF). 
При чтении количества костей появление конца файла обрабатывается иначе, чем ситуация с несоответствием типа; в первом случае происходит выход из цикла while, 
а во втором инициируется новая итерация цикла.
Функцию roll_n_dice() можно применять многими способами. 
В случае значения sides, равного 2, программа эмулирует процесс бросания монеты, при котором выпадение орла обозначается 2, а решки — 1 (или, если хотите, то наоборот). 
Вы можете легко модифицировать программу так, чтобы она показывала отдельные результаты и сумму, или построить эмулятор игры в кости. 
Если требуется большое количество бросаний, как в некоторых ролевых играх, несложно изменить программу
Функции randl() и rand() (но не rollern()) могут также использоваться для создания программы, в которой компьютер выбирает число, а вы его отгадываете.
Попробуйте написать ее самостоятельно.*/