/*Вас может интересовать, какова связь между классами хранения и динамическим распределением памяти. 
Давайте посмотрим на идеализированную модель. 
Вы можете думать о доступной памяти программы как об имеющей три отдельных области:
одна для статических переменных с внешним связыванием, внутренним связыванием и без связывания; 
одна для автоматических переменных; и одна для динамически выделяемой памяти.
Объем памяти, необходимый для классов со статической продолжительностью хранения, известен на этапе компиляции, и данные, которые хранятся в этой области,
доступны на всем протяжении выполнения программы. Каждая переменная этих классов появляется, когда программа запускается, и исчезает при ее завершении.
Однако автоматическая переменная начинает существовать, когда поток управления входит в блок кода, содержащий определение переменной, и исчезает после покидания
этого блока. 
Следовательно, по мере вызова программой функций и их завершения, объем памяти, задействованный под автоматические переменные, возрастает и уменьшается. 
Такая область памяти обычно реализована в виде стека. 
Это значит, что новые переменные добавляются в память последовательно, в порядке их создания, а удаляются в обратном порядке, когда исчезают.*/
/*Динамически выделяемая память появляется при вызове malloc() или родственной ей функции и освобождается при вызове free(). 
Постоянство памяти управляется программистом, а не каким-то набором жестких правил, поэтому блок памяти может быть создан в одной функции и освобожден в другой. 
По этой причине область памяти, применяемая для динамического распределения памяти, может стать фрагментированной, 
т.е. неиспользованные участки будут идти вперемешку с активными блоками памяти. 
Кроме того, использование динамической памяти имеет тенденцию быть более медленным процессом, чем работа со стековой памятью.
Обычно программа применяет разные области памяти для статических объектов, автоматических объектов и динамически выделенных объектов. 
Сказанное демонстрируется в листинге 12.15.*/
// Листинг 12.15. Программа where.c
// where.c -- где что находится в памяти?
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int static_store = 30;
const char *pcg = "String Literal"; // Строковый литерал
int main()
{
	int auto_store = 40;
	char auto_string[] = "Auto char Array"; // Автоматический массив char
	int *pi;
	char *pcl;

	pi = (int *) malloc(sizeof(int));
	*pi = 35;
	pcl = (char *) malloc(strlen("Dynamic String") + 1); // Динамическая строка
	strcpy(pcl, "Dynamic String"); // Динамическая строка

	printf("static_store: %d at %p\r\n", static_store, &static_store);
	printf("  auto_store: %d at %p\r\n", auto_store, &auto_store);
	printf("		 *pi: %d at %p\r\n", *pi, pi);
	printf("  %s at %p\r\n", pcg, pcg);
	printf(" %s at %p\r\n", auto_string, auto_string);
	printf("  %s at %p\r\n", pcl, pcl);
	printf("	%s at %p\r\n", "Quoted String", "Quoted String"); // Строка в ковычках
	free(pi);
	free(pcl);

	return 0;
}
/*Как видите, статические данные, включая строковые литералы, занимают одну область, 
автоматические данные - вторую область, а динамически выделенные данные - третью область (часто называемую кучей или свободным хранилищем).*/