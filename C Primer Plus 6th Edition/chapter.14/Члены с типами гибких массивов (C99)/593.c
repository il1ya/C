/*В стандарте С99 предлагается новое средство, которое называется членами типа гибкого массива. 
Оно позволяет объявлять структуру, последний член в которой является массивом со специальными свойствами. 
Одно из специальных свойств заключается в том, что такой массив не существует — во всяком случае, не появляется немедленно. 
Второе специальное свойство состоит в том, что при наличии корректного кода длен типа гибкого
массива можно использовать, как если бы он существовал и имел нужное количество элементов. 
Возможно, это звучит несколько своеобразно, так что давайте рассмотрим шаги по созданию и применению структуры с членом типа гибкого массива.
Для начала ниже представлены правила, регламентирующие создание члена типа гибкого массива.
• Член типа гибкого массива должен быть последним в структуре.
• В структуре должен присутствовать, по крайней мере, еще один член другого типа.
• Гибкий массив объявляется подобно обычному массиву, но с пустыми квадратными скобками.*/

/*Вот пример, иллюстрирующий эти правила:
struct flex
{
	int count;
	double average;
	double scores[]; // член типа гибкого массива
};
*/
/*Если вы объявили переменную типа struct flex, то не можете использовать член scores, т.к. память для него нс зарезервирована. 
На самом деле, даже не подразумевается, что вы будете объявлять переменные типа struct flex. 
Вместо этого предполагается, что вы объявите указатель на тип struct flex, а затем с помощью malloc()
выделите область памяти, достаточную для хранения обычного содержимого struct flex, плюс дополнительное пространство, 
которое необходимо для члена с типом гибкого массива. 
Например, пусть вы хотите, чтобы член scores представлял массив из пяти значений double. 
В этом случае понадобится поступить так:
struct flex *pf; // объявление указателя
// запрос области памяти для размещения структуры и массива
pf = malloc(sizeof(struct flex) + 5 * sizeof(double));
Теперь вы располагаете объемом памяти, которого достаточно для хранения count, average и массива из пяти значений double. 
Дл  доступа к этим членам можно применять указатель pf:
pf->count = 5; // установка члена count
pf->scores[2] = 18.5; // доступ к элементу члена типа массива
В листинге 14.12 пример продолжает развиваться; гибкий массив получает возможность представлять пять значений в первом случае и девять значений — во втором.
Здесь также демонстрируется написание функции для обработки структуры с членом типа гибкого массива.*/

// Листинг 14.12. Программа filexmemb.c
// flexmemb.c -- член типа гибкого массива (средство С99)

#include <stdio.h>
#include <stdlib.h>

struct flex
{
	size_t count;
	double average;
	double scores[]; // член с типом гибкого массива
};

void showFlex(const struct flex *p);
int main(void)
{ 
К обработке структур, содержащих члены с типами гибких массивов, предъявляется ряд специальных требований.
	struct flex *pf1, *pf2; // *pfl и *pf2 являются структурами || *pf2 = *pfl; // не поступайте так
/*Такой код привел бы к копированию только членов структуры, которые не относятся к типу гибкого массива. 
Вместо этого применяйте функцию memcpy(), которая описана в главе 16.*/
	/*Во-вторых, не используйте такие сруктуры совместно с функциями, которые передают структуры по значению. 
Причина такого ограничения та же — передача аргумента по значению подобна присваиванию. 
Вместо этого применяйте функции, которые передают адрес струкгуры.
	В-третьих, не используйте струкгуру с членом типа гибкого массива в качестве элемента массива или члена другой структуры.
Возможно, вы уже слышали о конструкции, подобной члену типа гибкого массива, которая называется прямом "struct hack". 
Вместо применения пустых квадратных скобок для объявления члена типа гибкого массива прием "struct hack" предусматривает указание нулевого размера массива. 
Однако данный прием работал только с конкреным компилятором (GCC); он не входил в стандарт С. 
Подход с использованием члена типа гибкого массива предлагает методику, одобренную стандартом.*/
	int n = 5;
	int i;
	int tot = 0;

	// выделение памяти для структуры и массива
	pf1 = malloc(sizeof(struct flex) + n *sizeof(double));
	pf1 -> count = n;
	for(i = 0; i < n; i++)
	{
		pf1 -> scores[i] = 20.0 - i;
		tot += pf1 -> scores[i];
	}
	pf1 -> average = tot / n;
	showFlex(pf1);
	n = 9;
	tot = 0;
	pf2 = malloc(sizeof(struct flex) + n *sizeof(double));
	pf2 -> count = n;
	for(i = 0; i < n; i++)
	{
		pf2 -> scores[i] = 20.0 - i / 2.0;
		tot += pf2 -> scores[i];
	}
	pf2 -> average = tot / n;
	showFlex(pf2);
	free(pf1);
	free(pf2);
	return 0;
}

void showFlex(const struct flex *p)
{
	int i;
	printf("Scores : ");
	for(i = 0; i < p -> count; i++)
		printf("%g ", p -> scores[i]);
	printf("\r\nAverage: %g\r\n", p -> average);
}