/*Средство составных литералов С99 доступно для структур, а также для массивов.
Оно удобно, если требуется всего лишь временное значение структуры. 
Например, составные литералы можно применять для создания структуры, предназначенной для использования в качестве артумента функции или для присваивания другой структуре.
Синтаксис составного литерала выглядит как заключенный в фигурные скобки список инициализаторов, которому предшествует имя типа в круглых скобках. 
Ниже представлен составной литерал типа struct book:
(struct book) {"Идиот", "Федор Достоевский", 6.99}
В листинге 14.11 приведен пример применения составных литералов для предоставления двух альтернативных значений переменной структуры. 
(На момент написания книги это средство поддерживалось не всеми компиляторами, но со временем ситуация должна поменяться.)*/
// Листинг 14.11. Программа complit.c
/*complit.c -- составные литералы*/
#include <stdio.h>

#define MAXTITL 41
#define MAXAUTL 31

struct book {			// шаблон структуры: book - дескриптор
	char title[MAXTITL];
	char author[MAXAUTL];
	float value;
};

int main(void)
{
	struct book readfirst;
	int score;
	printf("Enter test score: ");
	scanf("%d", &score);

	if(score >= 84)
		readfirst = (struct book) { " Crime and Punishment", " Fyodor Dostoyevsky", 11.25 };
	else
		readfirst = (struct book) { "Mr. Bouncy's Nice Hat", "Fred Winsome", 5.99 };
	printf("Your assigned reading:\r\n"); // Назначенные вами рейтинги
	printf("%s by %s: $%.2f\r\n", readfirst.title, readfirst.author, readfirst.value);
	return 0;
}
/*Составные литералы, которые встречаются за пределами любых функций, имеют статическую продолжительность хранения, а те, 
что находятся внутри блока - автоматическую продолжительность хранения. 
В отношении составных литералов действуют те же синтаксические правила, что и для обычных списков инициализаторов. 
Это значит, например, что в составных литералах можно применять назначенные инициализаторы.*/