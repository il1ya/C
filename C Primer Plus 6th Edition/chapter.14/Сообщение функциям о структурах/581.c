/*Вспомните, что аргументы функции передают ей значения. 
Каждое значение является числом — возможно, int, float, ДОСН-кодом символа или адресом.
Структура сложнее одиночного значения, поэтому не должно вызывать удивление то, что ранние реализации С не позволяют применять структуру в качестве аргумента для функции. 
В более новых реализациях это ограничение было снято, и ANSI С позволяет использовать струкгуры в аргументах функций. 
Таким образом, современные реализации С предлагают возможность выбора между передачей в качестве аргументов
самих структур и указателей на эти структуры, либо, если вас интересует только часть структуры — передачей в аргументах членов структуры. 
Мы исследуем все три метода, начав с передачи членов структуры как аргументов.
Передача членов структуры
До тех пор, пока член структуры имеет тип данных с единственным значением(т.е. int или один из его производных типов, char, float, double либо указатель), 
его можно передавать в качестве аргумента функции, которая принимает этот конкретный тип. 
Простейшая программа финансового анализа из листинга 14.5, которая складывает
сумму на обычном банковском счете клиента и сумму на его сберегательном счете, иллюстрирует это утверждение.*/
// Листинг 14.5. Программа funds1.c
/*funds1.c -- передача членов структуры в качестве аргументов*/

#include <stdio.h>

#define FUNDLEN 50
/*шаблон структуры: дескриптором является funds*/
struct funds
{
	char bank[FUNDLEN];
	double bankfund;
	char save[FUNDLEN];
	double savefund;
};

double sum(double, double);

int main(void)
{
	struct funds stan = 
	{
		"Garlic-Melon Bank",
		4032.27,
		"Lucky's Savings and Loan",
		8543.94
	};
/*Обратите внимание, что функция sum() не знает, да и не заботится о том, являются ли фактические аргументы членами структуры; 
она только требует, чтобы они имели тип double.*/
	printf("Stan has a total of $%.2f.\r\n", sum(stan.bankfund, stan.savefund));
	return 0;
}

/*суммирование двух чисел типа double*/
double sum(double x, double y)
{
	return(x + y);
}