/*Давайте расширим программу каталога книг для поддержки большего количества книг. 
Очевидно, что каждая книга может быть описана одной переменной типа book.
Чтобы описать две книги, необходимы две такие переменные и т.д. 
Для поддержки нескольких книг понадобится массив структур подобного рода, и его мы создадим в программе, показанной в листинге 14.2. 
(Если вы имеете дело с Вогland C/C++, ознакомьтесь с врезкой "Borland С и плавающая запятая" далее в главе.)

Структуры и память
В программе manybook.c применяется массив из 100 структур. 
Поскольку массив является объектом с автоматическим классом хранения, информация обычно размещается в стеке.
Крупный массив такого рода требует области памяти приличного размера, что может вызвать проблемы. 
Если во время выполнения вы получаете сообщение об ошибке, возможно, уведомляющее о переполнении стека, то ваш компилятор, скорее всего, использует
стандартный размер для стека, который слишком мал для этого примера. 
Чтобы исправить положение, вы можете с помощью опций компилятора установить размер стека в 10000,
обеспечив достаточное место для данного массива структур, или же сделать массив статическим либо внешним (тогда он не будет размещаться в стеке);
можно также уменьшить размер массива, к примеру, до 16. 
А почему мы изначально не выбрали массив небольшого размера? 
Причина в том, что вы должны знать об этой потенциальной проблеме с размером стека и уметь справляться с ней, когда она возникнет в будущей практике.*/

// Листинг 14.2. Программа manybook.c
/*manybook.c -- каталог для нескольких книг*/

#include <stdio.h>
#include <string.h>

char *s_gets(char *st, int n);

#define MAXTITL 40
#define MAXAULT 40
#define MAXBKS 100 				/*максимальное количество книг*/

struct book /*шаблон структуры: дескриптором является book*/
{
	char title[MAXTITL];
	char author[MAXAULT];
	float value;
}; /*конец шаблона структуры*/

int main(void)
{ 
/*	Объявление массива структур.
Здесь library объявляется как массив, содержащий MAXBKS элементов. Каждый элемент этого массива является структурой типа book. 
Таким образом, library[0] — одна структура типа book, library[1] — вторая структура типа book и т.д.*/
	struct book library[MAXBKS];     /*массив структур типа book*/
	int count = 0;
	int index;

	printf("Please enter the book title.\r\n"); // Введите название книги
	printf("Press [enter] at the start of a line to stop.\r\n"); // Нажмите [] в начале строки, чтобы закончить ввод.
/*Основное отличие этой программы от первой заключается в том, что в ней включен цикл для чтения множества записей. Цикл начинается со следующего условия while:*/
	while(count < MAXBKS && s_gets(library[count].title, MAXTITL) != NULL && library[count].title[0] != '\0')
/*Выражение s_gets(library[count].title, MAXTITL) читает строку для названия книги; это выражение принимает значение NULL, 
если функция s_gets() пытается прочитать символ, следующий за концом файла.	*/	

/*Выражение library[count].title[0] != '\0' проверяет, не является ли первый символ строки нулевым (т.е. не пустая ли строка).
Если пользователь нажимает клавишу <Enter> в начале строки, передатся пустая строка и цикл завершается.*/
	{
		printf("Now enter the author.\r\n"); // Теперь введите ФИО автора.
		s_gets(library[count].author, MAXAULT);
		printf("Now enter the value.\r\n"); // Теперь введите цену.
		scanf("%f", &library[count++].value);
		while(getchar() != '\n')
			continue; /*очистить входную строку*/
		if(count < MAXBKS)
			printf("Enter the next title.\r\n");
	}
	if(count > 0)
	{
		printf("Here is the list of your books:\r\n");
		for(index = 0; index < count; index++)
			printf("%s by %s: $%.2f\r\n", library[index].title, library[index].author, library[index].value);
	}
	else
		printf("No books? Too bad.\r\n");
	return 0;
}

char *s_gets(char *st, int n)
{
	char *ret_val;
	char *find;

	ret_val = fgets(st, n, stdin);
	if(ret_val)
	{
		find = strchr(st, '\n');  	// поиск новой строки
		if(find)					// если адрес не равен NULL
			*find = '\0';			// поместить туда нулевой символ
		else
/*этот код компенсирует игнорирование функцией scanf() пробелов и символов новой строки.*/
			while(getchar() != '\n')
				continue;			// отбросить остаток строки
	}
	return ret_val;
}
