/*	Современный язык С позволяет присваивать одну структуру другой — то, чего нельзя делать с массивами. 
То есть, если n_data и o_data — структуры того же типа, то можно записать следующий код:
	o_data = n_data; // присваивание одной структуры другой
Это приводит к тому, что каждому члену n_data присваивается значение соответствующего члена o_data. 
Это работает, даже если член оказывается массивом. 
Кроме того, структуру можно инициализировать другой струкурой того же типа:
	struct names right_field = {"Джеймс", "Бонд"};
	struct names captain = right_field; // инициализация структуры другой структурой
	В современном языке С, включая ANSI С, структуры не только можно передавать функции в качестве артументов, но также и возвращать их из функции. 
Применение структур в аргументах функции позволяет передавать ей информацию о структуре.
Использование функций для возвращения структур дает возможность передавать информацию о структуре из вызываемой функции в вызывающую. 
Указатели на структуры также допускают двусторонний обмен данными, так что вы часто будете применять один из этих подходов при решении разнообразных задач. 
Рассмотрим еще один набор примеров, иллюстрирующих данные два подхода.

	Чтобы сравнить эти два подхода, мы напишем простую программу, которая обрабатывает структуры с использованием указателей, и затем переделаем ее так, чтобы
в ней выполнялась передача и возвращение структур. 
Сама программа запрашивает имя и фамилию и сообщает общее количество букв в них. 
Этот проект едва ли требует структур, но он предлагает простую инфраструктуру, которая позволяет увидеть, как они работают. 
В листинге 14.8 представлена версия программы с указателями.*/
// Листинг 14.8. Программа names1.c
/*names1.c -- использует указатели на структуры*/
#include <stdio.h>
#include <string.h>

#define NLEN 30

struct namect
{
	char fname[NLEN];
	char lname[NLEN];
	int letters;
};
void getinfo(struct namect *);
void makeinfo(struct namect *);
void showinfo(const struct namect *);
char *s_gets(char *st, int n);

int main(void)
{
/*Работа программы распределена между тремя функциями, вызываемыми в main().
В каждом случае функции передается адрес структуры person.*/
	struct namect person;
	getinfo(&person);
	makeinfo(&person);
	showinfo(&person);
	return 0;
}

/*Функция getinfo() передает информацию изнутри себя в main(). 
В частности, она полукает имена от пользователя и помещает их в структуру person, применяя для доступа к ней указатель pst.*/
/*Вспомните, что pst -> lname означает член lname структуры, на которую указывает pst. 
Это делает pst -> lname эквивалентом имени массива значений char и, следовательно, подходящим артументом для функции gets().
Обратите внимание, что хотя функция getinfo() снабжает информацией главную программу, она не использует для этого механизм возврата, поэтому имеет тип void.*/
void getinfo(struct namect *pst)
{
	printf("Enter enter your first name.\r\n");
	s_gets(pst -> fname, NLEN);
	printf("Please enter your last name.\r\n");
	s_gets(pst -> lname, NLEN);
}

/*Функция makeinfo() выполняет двустороннюю передачу информации. С применением указателя на person она находит имя и фамилию, хранящиеся в этой структуре.
Она использует функцию strlen() из библиотеки С для подсчета количества букв в имени и фамилии, 
а затем применяет адрес структуры person для сохранения полученной суммы. 
Эта функция также имеет тип void.*/
void makeinfo(struct namect *pst)
{
/*Функция strlen видит начало Си-строки  и начинает сначала считать количество символов (байтов, отводимых под каждый символ), 
этот процесс выполняется до тех пор, пока не будет достигнут завершающий нулевой символ.*/
	pst -> letters = strlen(pst -> fname) + strlen(pst -> lname);
}

/*И, наконец, функция showinfo() использует указатель для доступа к информации, предназначенной для вывода. 
Поскольку showinfo() не изменяет содержимое массива, указатель объявлен как const.*/
void showinfo(const struct namect *pst)
{
	printf("%s %s, your name contains %d letters.\r\n", pst -> fname, pst -> lname, pst -> letters); // Ваше имя и фамилия содержат букв
}
/*Во всех этих операциях участвовала всего лишь одна переменная типа структуры person, и каждая из функций для доступа к структуре применяла ее адрес. 
Первая функция передавала информацию изнутри себя вызывающей программе, вторая функция
принимала информацию из вызывающей программы внутрь себя, а третья функция делала то и другое.*/

char *s_gets(char *st, int n)
{
	char *ret_val;
	char *find;

	ret_val = fgets(st, n, stdin);
	if(ret_val)
	{
		find = strchr(st, '\n'); // поиск новой строки
		if(find)				 // если адрес не равен NULL
			*find = '\0';		 // поместить туда нулевой символ
		else
			while(getchar() != '\n')
				continue;		 // отбросить остаток строки
	}
	return ret_val;
}