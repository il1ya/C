/*Любители указателей будут рады узнать о возможности иметь указатели на структуры. 
Существуют, по меньшей мере, четыре причины, обусловливающие необходимость в указателях на структуры. 
Во-первых, точно так же, как манипулировать указателями на массивы проще, чем самими массивами (скажем, в задаче сортировки), 
с указателями на структуры часто работать легче, чем с самими структурами. 
Во-вторых, в некоторых старых реализациях структура не может быть передана как аргумент функции, но указатель на структуру — может. 
В-третьих, несмотря на то, что структуру можно передавать в качестве аргумента, передача указателя зачастую эффективнее.
И, в-четвертых, многие замысловатые представления данных применяют структуры, содержащие указатели на другие структуры.
Следующий краткий пример(листинг 14.4) демонстрирует определение указателя на структуру и его использование для доступа к членам структуры.*/
// Листинг 14.4. Программа friends.с
/*friends.c -- использование указателя на структуру*/

#include <stdio.h>

#define LEN 20
/*Структура — тип данных: запись, состоящая из нескольких переменных (или констант) разного типа.*/
/*шаблон структуры: дескриптором является names*/
struct names // первая структура
{
	char first[LEN];
	char last[LEN];
};
/*шаблон структуры: дескриптором является guy*/
struct guy // вторая структура
{
	struct names handle;
	char favfood[LEN];
	char job[LEN];
	float income;
};

int main(void)
{
	struct guy fellow[2] = 
	{
		{{ "Ewen", "Villard" }, // Билли Бонс
		"grilled salmon", // запеченными омарами
		"personality coach", // персональный тренер
		68112.00
	},
		{{ "Rodney", "Swillbelly" }, // Джим Хокинс
		"tripe", // рыбным фриксе
		"tabloid editor", // редактор таблоида
		232400.00
		}
	};
/*Объявление и инициализация указателя на структуру*/
	struct guy *him; /*указатель на структуру*/
/*Первым идет ключевое слово struct, затем дескриптор структуры guy, звездочка (*) и, наконец, имя указателя.*/
/*Объявление не приводит к созданию новой структуры, но указатель him теперь может ссылаться на любую существующую структуру типа guy.*/
	printf("address #1: %p #2: %p\r\n", &fellow[0], &fellow[1]);
/*В нашем примере fellow — массив структур, т.е. fellow[0] представляет собой структуру, поэтому код инициализирует him, 
делая его указывающим на fellow[0]*/
	him = &fellow[0]; /*сообщает указателю, на что указывать*/
	printf("pointer #1: %p #2: %p\r\n", him, him + 1);
/*Первые две строки вывода показывают, что присваивание прошло успешно.
Сравнивая эти две строки, мы видим, что him указывает на fellow[0], а him + 1 — на fellow[1].*/
	printf("him -> income is $%.2f: (*him).income is $%.2f\r\n", him -> income, (*him).income);
/*->. Знак этой операции образован из дефиса (-) и символа "больше" (>).*/

/*him->income равно barney.income, если him == &barney
him->income равно fellow[O].income, если him == &fellow[0]*/

/*Другими словами, указатель на структуру, за которым следует операция ->, работает таким же образом, как имя структуры с последующей операцией точки(.). 
(Вы не можете использовать просто him.income, потому что him не является именем структуры.)
Важно отметить, что him — указатель, но him -> income — это член структуры, на которую он указывает.
Это значит, что в данном случае him -> income представляет собой переменную типа float.*/

	him++;		/*указатель на следующую структуру*/
	printf("him -> favfood is %s: him -> handle.last is %s\r\n", him -> favfood, him -> handle.last);

	return 0;
}