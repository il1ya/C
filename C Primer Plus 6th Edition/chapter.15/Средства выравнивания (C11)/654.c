/*Средства выравнивания С11 по своей природе больше ориентированы на манипулирование байтами, чем битами, но они также отражают возможность языка С иметь дело с оборудованием. 
В этом контексте выравнивание относится к тому, как объекты располагаются в памяти. 
Например, для максимальной эффективности система может требовать, чтобы значение типа double хранилось в памяти по адресу, кратному 4, но разрешать значению типа char храниться по любому адресу. 
Большинству программистов редко когда придется заботиться о выравнивании. Но в некоторых ситуациях
контроль над выравниванием позволяет извлечь выгоду, например, при передаче данных из одного физического места в другое либо при вызове инструкций, которые оперируют на множестве элементов данных одновременно.
Операция _Alignof выдает требования к выравниванию указанного типа. Для ее
использования необходимо после ключевого слова _Alignof поместить имя тина в круглых скобках:
	size_t d_align = _Alignof(float);
Полученное значение, скажем, 4 для d_align, говорит о том, что объекты float имеют требование к выравниванию, соответствующее 4. 
Это означает, что 4 является количеством байтов между следующими друг за другом адресами для хранения значений упомянутого типа. 
В общем случае значения выравнивания должны быть неотрицательными целыми числами, которые представляют собой степень 2. 
Более высокие значения выравнивания считаются более жесткими или более строгими, чем меньшие значения, в то время как меньшие значения трактуются как более слабые.
С помощью спецификатора _Alignas можно запрашивать конкретное выравнивание для переменной или типа. 
Однако вы не должны запрашивать выравнивание, которое слабее фундаментального выравнивания, принятого для типа. 
Например, если требование к выравниванию для float составляет 4, не запрашивайте значение выравнивания, равное 1 или 2. 
Этот спецификатор применяется как часть объявления, и за ним следует пара круглых скобок, содержащая либо значение выравнивания, либо тип:
	_Alignas(double) char cl;
	_Alignas(8) char с2;
	unsigned char _Alignas(long double) c_arr[sizeof(long double)];
В листинге 15.5 показан короткий пример использования _Alignas и _Alignof.*/
// Листинг 15.5. Программа align.c
// align.c -- использование _Alignof и _Alignas (C11)
#include <stdio.h>
int main(void)
{
	double dx;
	char ca;
	char cx;
	double dz;
	char cb;
	char _Alignas(double) cz;

	printf("char aligment: %zd\r\n", _Alignof(char));
	printf("double aligment: %zd\r\n", _Alignof(double));
	printf("&dx: %p\r\n", &dx);
	printf("&ca: %p\r\n", &ca);
	printf("&cx: %p\r\n", &cx);
	printf("&dz: %p\r\n", &dz);
	printf("&cb: %p\r\n", &cb);
	printf("&cz: %p\r\n", &cz);
	return 0;
}

/*В нашей системе значение выравнивания 8 для типа double подразумевает, что значения этого типа сохраняются по адресам, кратным 8. 
Шестнадцатеричные адреса, заканчивающиеся на О или 8, являются кратными 8, и адреса такого вида применялись
для двух переменных double, а также переменной char по имени cz, которой было назначено значение выравнивания для типа double. 
Поскольку значением выравнивания для char было 1, компилятор мог использовать для переменных этого типа любые адреса.
Включение заголовочного файла stdalign.h позволяет применять псевдонимы alignas и alignof для _Alignas и _Alignof. 
Они соответствуют ключевым словам в C++. 
В C11 также появилась возможность выравнивания для выделенной памяти за счет добавления в библиотеку stdlib.h новой функции распределения памяти со следующим прототипом:
void *aligned_alloc(size_t alignment, size_t size);
В первом параметре указывается требуемое выравнивание, а во втором — количество необходимых байтов, которое должно быть кратным значению первого параметра.
Как и в случае других функций распределения памяти, по завершении работы с выделенной памятью используйте функцию free() , чтобы ее освободить.*/