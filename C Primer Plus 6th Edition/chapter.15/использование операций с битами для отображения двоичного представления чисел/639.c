/*В главе 9 при написании программы преобразования чисел в двоичное представление мы использоваш рекурсию. 
Теперь мы решим ту же задачу с применением побитовых операций. 
Программа в листинге 15.1 читает вводимое с клавиатуры целое
число и передает его вместе с адресом строки в функцию по имени itobs(), которая строит для целочисленного значения строку с двоичным представлением. 
Для определения подходящей комбинации 0 и 1, помещаемой в строку, эта функция использует побитовые операции.*/
// Листинг 15.1. Программа binbit.c
/*binbit.c -- использование операций с битами для отображения двоичного представления чисел*/

#include <stdio.h>
#include <limits.h> // для CHAR_BIT количество битов на символ

char *itobs(int, char *);
void show_bstr(const char *);

int main(void)
{
	char bin_str[CHAR_BIT *sizeof(int) + 1];  // макрос CHAR_BIT из заголовочного файла limits.h. Этот макрос представляет количество битов в типе char.
/*операция sizeof возвращает размер в терминах char, поэтому выражение CHAR_BIT *sizeof(int) дает количество битов в значении int.*/
	int number;

	puts("Enter integers and see them in binary."); // Вводите целые числа и просматривайте их двоичные представления
	puts("Non-numeric input terminates program."); // Нечисловой ввод завершает программу
	while(scanf("%d", &number) == 1)
	{
		itobs(number, bin_str); 
/*Функция itobs() возвращает тот же самый адрес, который ей был передан, так что ее вызов можно использовать, к примеру, в качестве аргумента printf().*/
		printf("%d"); // представляется как
/*Для отображения результирующей строки можно применять printf() или puts().
Тем не менее, в листинге 15.1 определена функция show_bstr(), которая разбивает последовательность битов на группы по четыре, чтобы облегчить восприятие строки.*/
		show_bstr(bin_str);
		putchar('\n');
	}
	puts("Bye!"); // программа завершена
	return 0;
}

char *itobs(int n, char *ps)
{
	int i;
	const static int size = CHAR_BIT *sizeof(int);
/*Затем в цикле выполняются операторы i-- и n >>= 1.
Первый оператор приводит к переходу на предыдущий элемент массива, а второй сдвигает биты в n на одну позицию вправо. 
На следующей итерации цикла код найдет значение нового самого правого бита. 
После этого соответствующий ему символ цифры помещается в элемент, предшествующий последней цифре. 
В подобной манере функция заполняет массив справа налево.*/
	for(i = size - 1; i >= 0; i--, n >>= 1)
		ps[i] = (01 & n) + '0'; // предполагается кодировка ASCII или похожая
/*Операнд 01 — это восьмеричное представление маски, у которой все биты кроме нулевого установлены в О. Следовательно, результатом О1 & n будет значение последнего бита в n. 
Значением является О или 1, но для массива необходим символ '0' или символ '1'. Преобразование осуществляется добавлением кода для 'О'. 
(Это предполагает, что цифры кодируются последовательно, как в ASCII.) Результат помещается в предпоследний элемент массива. (Последний элемент зарезервирован для нулевого символа.)*/
	ps[size] = '\0';
	return ps;
}
/*отображение двоичной строки блоками по 4*/
void show_bstr(const char *str)
{
	int i = 0;

	while(str[i]) /*пока не будет получен нулевой символ*/
	{
		putchar(str[i]);
		if(++i % 4 == 0 && str[i])
			putchar(' ');
	}
}