/*Строковые литералы считаются данными const. 
Поскольку указатель ptl ссылается на такие данные, он должен быть объявлен, как указывающий на данные const.
Это вовсе не означает, что нельзя изменять значение ptl (т.е. место, на которое он указывает), просто ptl не допускается применять для изменения самих данных. 
С другой стороны, при копировании строкового литерала в массив данные можно свободно изменять, если только сам массив не был объявлен как const.
Короче говоря, инициализация массива приводит к копированию строки из статической памяти в массив, тогда как инициализация указателя просто копирует адрес строки. 
Эти утверждения демонстрируются в листинге 11.3.*/
// Листинг 11.3. Программа addresses.c
// addresses.c -- адреса строк
#include <stdio.h>
#define MSG "I'm special."
int main(void)
{
	char ar[] = MSG;
	const char *pt = MSG;
	printf("address of \"I'm special\": %p\r\n", "I'm special");
	printf("		address ar: %p\r\n", ar);
	printf("		address pt: %p\r\n", pt);
	printf("	    address of MSG: %p\r\n", MSG);
	printf("address of \"I'm special\": %p\r\n", "i'm special");
	return 0;
}
/*pt и MSG — это один и тот ж е адрес, но ar, как и было сказано, является другим адресом. 
Во-вторых, хотя литерал ”Я особенный. " встречается в операторах printf() дважды, компилятор использует одну область памяти, но с адресом, отличающимся от адреса MSG. 
Компилятору предоставляется свобода выбора сохранять литерал, который применяется более одного раза, в одном или нескольких местах.*/