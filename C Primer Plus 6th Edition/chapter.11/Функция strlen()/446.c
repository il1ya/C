/*Как вы уже знаете, функция strlen() находит длину строки. Она используется в следующем примере функции, которая сокращает длинные строки:
void fit(char *string, unsigned int size)
{
	if (strlen(string) > size)
	string[size] = '\0';
}
Функция изменяет строку, поэтому в ее заголовке при объявлении формального параметра string модификатор const не указан.
Функцию fit() можно протестировать с помощью программы, приведенной в листинге 11.17. Обратите внимание, что в коде применяется конкатенация строковых литералов С.*/
// Листинг 11.17. Программа test_fit.c
// test_fit.c -- использование функции укорачивания строк
#include <stdio.h>
#include <string.h> // содержит прототипы строковых функций
void fit(char *, unsigned int);
int main(void)
{
	char mesg[] = "Things should be as simple as possible," // Все должно быть максимаольно простым
	" but not simple."; // но не более
	puts(mesg);
	fit(mesg, 35);
	puts(mesg);
	puts("Let's look at some more of the string.");
	puts(mesg + 36);
	return 0;
}
void fit(char *string, unsigned int size)
{
	if(strlen(string) > size)
		string[size] = '\0';
}

/*функция fit() помещает символ '\0' в 36-й элемент массива вместо символа запятой.
Она останавливается при обнаружении первого нулевого символа, игнорируя оставшуюся часть массива.  
Тем не менее, остальная часть массива никуда не делась, как показывает следующий вызов функции: puts(mesg + 36);
Выражение mesg + 36 дает адрес элемента mesg[36], которым является символ пробела. 
Таким образом, puts() отображает этот символ и продолжает работу до тех пор, пока не столкнется с исходным нулевым символом.*/

/*Заголовочный файл string.h содержит прототипы для семейства строковых функций С, поэтому он и был включен в данном примере.*/

/*На заметку!
В некоторых системах, существовавших до выхода стандарта ANSI, вместо string.h используется заголовочный файл strings.h, 
а в ряде систем такой заголовочный файл вообще отсутствует.*/