/*В листинге 11.9 представлен один из способов применения функции fgets(): чтение всей строки и замена символа новой строки нулевым символом 
либо чтение части строки, умещающейся в заданную область памяти, и отбрасывание остальных символов— т.е. своего рода разновидность функции getss(), 
но без дополнительных препятствий. Ни одна из стандартных функций не удовлетворяет этому описанию, но мы можем создать такую функцию самостоятельно. 
Она пригодится в будущих примерах. 
В листинге 11.10 демонстрируется один из подходов.*/
// Листинг 11.10. Функция s_gets()
char *s_gets(char *st, int n)
{
	char *ret_val;
	int i = 0;
	ret_val = fgets(st, n, stdin);
	if(ret_val) // т.е. ret_val != NULL
	{
		while(st[i] != '\n' && st[i] != '\0')
			i++;
		if(st[i] == '\n')
			st[i] = '\0';
		else // требуется наличие words[i] == '\0'
			while(getchar() != '\n')
				continue;
	}
	return ret_val;
}
/*В то время как функция fgets() возвращает NULL, указывая на конец файла или ошибку чтения, функция s_gets() пропускает обработку остальных данных. 
В противном случае она имитирует работу программы из листинга 11.9, заменяя в строке
символ новой строки нулевым символом, если названный символ присутствует, и отбрасывая остальную часть строки в противоположной ситуации. 
Затем она возвращает то же самое значение, что и fgets(). Мы будем использовать эту функцию в последующих примерах.
Возможно, вас интересует, в чем смысл отбрасывания остальной части слишком длинной строки. 
Проблема в том, что если остальную часть строки оставить, она становится входными данными для следующего оператора чтения. 
Это может, например, вызвать аварийное завершение программы, если следующий оператор чтения ожидает значение типа double. 
Обрасывание остальной части строки подлерживает операторы чтения в состоянии синхронизации с вводом с клавиатуры.
Наша функция s_gets() не идеальна. Наиболее серьезный ее недостаток в том, что она молча отбрасывает лишние входных данных, не ставя об этом в известность ни программу 
ни пользователя, и тем самым лишая его других возможностей, таких как повторение ввода или нахождение большего объема памяти. 
Еще один недостаток— отсутствие мер на случай неправильного применения вроде передачи размера, равного 1 или меньше. 
Тем не менее, эта функция вполне может служить заменой функции gets() в наших примерах.*/