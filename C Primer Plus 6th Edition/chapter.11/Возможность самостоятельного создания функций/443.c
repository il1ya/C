/*При вводе и выводе вы не ограничены только функциями стандартной библиотеки С. 
Если они недоступны или по какой-то причине не нравятся, можете подготовить собственные версии на основе футкций getchar() и putchar(). 
Предположим, что вам нужна функция, подобная puts() , которая не добавляет автоматически символ новой строки. 
В листинге 11.14 продемонстрирован один из способов создания такой функции.*/
// put1.c -- выводит строку без добавления символа \n

#include <stdio.h>
void put1(const char *string) // строка не изменяется
{
	while(*string != '\0')
		putchar(*string++);
}

/*Указатель string на char изначально ссылается на первый элемент переданного аргумента. Поскольку эта функция не изменяет строку, применяется модификатор const. 
После того, как содержимое этого элемента выведено, указатель инкрементируется и указывает на следующий элемент. 
Это продолжается до тех пор, пока указатель не будет ссылаться на элемент, содержащий нулевой символ. 
Вспомните, что операция++ имеет более высокий приоритет, чем *, так что вызов putchar (*string++)
выводит значение, на которое указывает string, но инкрементирует сам указатель string, а не символ, на который он ссылается.
Функцию putl.с можно рассматривать как модель для написания функций обработки строк. 
Поскольку каждая строка содержит нулевой символ, обозначающий ее конец, передавать функции размер строки не нужно. 
Вместо этого функция обрабатывает символы по очереди, пока не встретит нулевой символ.
*/


/*Почему в листинге 11.14 в качестве формального аргумента используется const char *string, а не const char string[]? 
Формально они эквивалентны, поэтому будет работать любая форма. Одна из причин применения формы записи с квадратными скобками —
желание напомнить пользователю, что данная функция обрабатывает массив. 
Тем не менее, в случае строк фактическим аргументом может быть имя массива, строка в кавычках или переменная, которая была объявлена с типом char *. 
Использование const char * string напоминает о том, что фактическим аргументом не обязательно должен быть массив.*/