/*Этот прием можно распространить на двумерные и многомерные массивы. 
Ниже приведен пример создания двумерного массива значений int и сохранения его адреса:
int (*pt2) [4); // объявление указателя на массив из массивов с 4 значениями int
pt2 = (int [2][4]) { {1,2,3,-9}, {4,5,6,-8} };
В данном случае типом является int[2][4] — массив 2х4 значений int.
В листинге 10.19 все эти примеры объединены в одну завершенную программу.*/
// Листинг 10.19. Программа flc.c
// flc.c -- забавно выглядящие константы
#include <stdio.h>
#define COLS 4
int sum2d(const int ar[][COLS], int rows);
int sum(const int ar[], int n);
int main(void)
{
	int total1, total2, total3;
	int *pt1;
	int (*pt2)[COLS];
	pt1 = (int [2]) {10, 20}; // составной литерал
	pt2 = (int [2][COLS]) { {1, 2, 3, -9}, {4, 5, 6, -8} };
	total1 = sum(pt1, 2);
	total2 = sum2d(pt2, 2);
	total3 = sum((int []) {4, 4, 4, 5, 5, 5}, 6);
	printf("total1 = %d\r\n", total1);
	printf("total2 = %d\r\n", total2);
	printf("total3 = %d\r\n", total3);
	return 0;
}
int sum(const int ar[], int n)
{
	int i;
	int total = 0;
	for(i = 0; i < n; i++)
		total += ar[i];
	return total;
}
int sum2d(const int ar[][COLS], int rows)
{
	int r;
	int c;
	int tot = 0;
	for(r = 0; r < rows; r++)
		for(c = 0; c < COLS; c++)
			tot += ar[r][c];
		return tot;
}
/*Имейте в виду, что составной литерал — это средство для предоставления значений, которые нужны лишm временно. 
Его область действия ограничена блоком, как будет прояснено в главе 12. 
Это значит, что его существование не гарантируется после того, как поток выполнения программы покинет блок, 
в котором определен составной литерал, т.е. самую внутреннюю пару фигурных скобок, содержащую определение.*/