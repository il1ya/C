/*
Массивы применяются в огромном числе ситуаций. В листинге scores_in.c демонстрируется относительно простой случай. 
Эта программа считывает 10 результатов игры в гольф, которые позже будут обрабатываться. 
За счет использования массива вы избегаете необходимости объявлять 10 переменных с разными именами, по одной для каждого результата. 
Кроме того, для чтения входных данных можно применять цикл for.
Программа предназначена для подсчета общей суммы результатов, их среднего значения и гандикапа, 
который представляет собой разность между средним и стандартным результатом, или паром. 
(Пар — это термин в гольфе, означающий количество ударов по мячу, которое необходимо опытному игроку для проведения мяча в лунку
или прохода всех лунок — прим.перев.)
*/ 

// использование циклов для обработки массивов

#include <stdio.h>
#define SIZE 10
#define PAR 72
int main (void)
{
	int index, score[SIZE];
	int sum = 0;
	float average;
	printf("Enter %d golf scores:\r\n", SIZE);
	for (index = 0; index < SIZE; index++)
		scanf("%d", &score[index]); // чтение 10 результатов игры в гольф
	printf("The scores read in are as follows:\r\n"); // Введены следующие результаты:
	for (index = 0; index < SIZE; index++)
		printf("%5d", score[index]); // проверка введенной информации
	printf("\r\n");
	for (index = 0; index < SIZE; index++)
		sum += score[index]; // сложение результатов
	average = (float) sum / SIZE; // проверенный временем метод
	printf("Sum of scores = %d, average = %.2f\r\n", sum, average); // Сумма результатов =, среднее значение =.
	printf("That's a handicap of %.0f.\r\n", average - PAR); // Полученный гандикап равен.
	return 0;
}
/*
Программа работает, поэтому приступим к исследованию деталей. 
Прежде всего, обратите внимание, что хотя в примере было набрано 11 чисел, прочитались только
10 из них, т.к. цикл чтения считывает только 10 значений. 
Поскольку функция scanf() пропускает пробельные символы, можно вводить в одной строке все 10 чисел, вводить каждое число в отдельной строке либо, 
как в рассматриваемом случае, для разделения значений воспользоваться смесью символов новой строки и пробела.
(Из-за буферизации ввода числа передаются в программу только после нажатия клавиши <Enter>.)
Работать с массивами и циклами гораздо удобнее, чем применять 10 операторов
scanf() и 10 операторов printf() для чтения и вывода 10 результатов. 
Цикл for предлагает простой и прямолинейный способ использования индексов массива.
Следует отметить, что элемент массива int обрабатывается подобно переменной типа int. 
Для чтения переменной fue типа in t применялся бы вызов scanf ("%d", &fue).
В листинге scores_in.c считывается элемент score [index] типа int, поэтому используется вызов scanf("%d", &score[index]).
В данном примере проиллюстрировано несколько аспектов, касающихся стиля программирования. 
Во-первых, применение директивы #define для создания символической константы (SIZE), указывающей размер массива, является хорошей идеей.
Эта константа используется в определении массива и при установке пределов в циклах.
Если позже понадобится расширить программу для обработки 20 результатов, достаточно просто переопределить константу SIZE, сделав ее равной 20. 
Вам не придется изменять каждую часть программы, в которой участвует размер массива. 
Во-вторых, конструкция for (index = О; index < SIZE; index++)
удобна для обработки массива с размером SIZE. 
Очень важно указывать правильные пределы массива. 
Первый элемент имеет индекс О, и цикл начинается с установки index в О. 
Поскольку нумерация начинается с О, индексом последнего элемента является SIZE - 1. 
То есть десятый элемент массива — это score [9]. 
Условие проверки index < SIZE обеспечивает это, делая последним применяемым значением index величину SIZE - 1.
В-третьих, в программах рекомендуется выводить на экран значения, которые были только что прочитаны (для эхо-контроля). 
Это помогает удостовериться в том, что программа обрабатывает именно те данные, которые ожидаются.
Наконец, в-четвертых, обратите внимание на использование в листинге 6.19 трех отдельных циклов for. 
Вас может интересовать, действительно ли это необходимо.
Можно ли объединить некоторые из операций в один цикл? Да, вы могли бы поступить так. 
Программа стала бы компактнее. Однако это противоречило бы принципу модульноспш. 
Идея, лежащая в основе этого термина, заключается в том, что программа должна быть разбита на отдельные модули, 
и каждый модуль должен решать одну задачу. 
Это облегчает чтение программы. Но что вероятно даже важнее — модульность намного упрощает обновление или модификацию программы, 
потому что ее части не перемешаны. Когда вы обретете достаточные знания о функциях, то сможете поместить
каждый модуль в функцию, улучшая модульность программы.
*/ 