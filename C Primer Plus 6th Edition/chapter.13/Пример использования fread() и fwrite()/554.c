/*
Давайте воспользуемся некоторыми из этих функций в программе, которая добавляет содержимое из списка файлов в конец указанного файла. 
Одна из задач заключается в передаче внутрь программы информации о файлах. Это можно делать интерактивно или с помощью аргументов командной строки. 
Мы примем первый подход, который предполагает выполнение перечисленных ниже действий.

• Запрос имени файла назначения и его открытие.
• Применение цикла для запроса исходных файлов.
• Поочередное открытие каждого исходного файла в режиме чтения и добавление его содержимого в конец файла назначения.

Чтобы проиллюстрировать работу функции setvbuf(), мы применим ее для установки другого размера буфера. 
Следующий этап детализации связан с открытием файла назначения. Мы будем использовать следующие шаги.

1. Открытие файла назначения в режиме добавления.
2. Если сделать это не удается, то завершение работы.
3. Установка буфера размером 4096 байтов для этого файла.
4. Если сделать это не удается, то завершение работы.

Аналогично, мы можем уточнить часть программы, отвечающую за копирование, для чего выполнить с каждым файлом такие действия.

• Если это файл назначения, то пропустить его и перейти к следующему файлу.
• Если файл не может быть открыт в режиме чтения, то пропустить его и перейти к следующему файлу.
• Добавить содержимое файла в файл назначения.

В завершение программа перейдет в начало файла назначения и отобразит его содержимое.
В целях практики для копирования будут применяться функции fread() и fwrite(). 
Результирующий код приведен в листинге 13.5.
*/
// Листинг 13.5. Программа append.c
/* append.c -- добавление содержимого файлов в файл назначения */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BUFSIZE 4096
#define SLEN 81

void append(FILE *source, FILE *dest);
char *s_gets(char *st, int n);

int main(void)
{
	FILE *fa, *fs; 			// fa для файла назначения, fs для исходного файла
	int files = 0; 			// количество добавляемых файлов
	char file_app[SLEN]; 	// имя файла назначения
	char file_src[SLEN];	// имя исходного файла
	int ch;

	puts("Enter name of destination file:"); // Введите имя файла назначения
	s_gets(file_app, SLEN); /*Для получения имени файла в программе применяется функция s_gets() вместо
scanf(), т.к. scanf() пропускает пробельные символы и, следовательно, не сможет обнаружить пустую строку.*/
/* Кроме того, в программе используется s_gets() вместо простой функции fgets(), потому что fgets() оставляет в строке символ новой строки. */
	if((fa = fopen(file_app, "a+")) == NULL)
/*		В примере используются файлы в текстовом режиме; путем применения режимов "аЬ+" и "rb" можно было бы обрабатывать двоичные файлы.*/
	{
		fprintf(stderr, "Can't open %s\r\n", file_app);
		exit(EXIT_FAILURE);
	}

	if(setvbuf(fa, NULL, _IOFBF, BUFSIZE) != 0)
	{
		fputs("Can't create output buffer\r\n", stderr); // Не удается создать выходной буфер
		exit(EXIT_FAILURE);
	}
	puts("Enter name of first source file (enpty line to quit):"); // Введите имя первого исходного файла (или пустую строку для завершения)
	
	while(s_gets(file_src, SLEN) && file_src[0] != '\0')
	{
		if(strcmp(file_src, file_app) == 0)
			/*Аргумент file_app представляет имя файла назначения, а file_src — имя файла, обрабатываемого в текущий момент.*/
			fputs("Can't append file to itself\r\n", stderr); // Добавить файл в конец самого себя невозможно
		else if((fs = fopen(file_src, "r")) == NULL)
			fprintf(stderr, "Can't open %s\r\n", file_src);
		else
		{
			if(setvbuf(fs, NULL, _IOFBF, BUFSIZE) != 0)
			{
				fputs("Can't create input buffer\r\n", stderr); // Не удается создать входной буфер
				continue;
			}
			append(fs, fa);
			if(ferror(fs) != 0)
				fprintf(stderr, "Error in reading file %s.\r\n", file_src); // Ошибка при чтении файла
			if(ferror(fa) != 0)
				fprintf(stderr, "Error in writing file %s.\r\n", file_app); // Ошибка при чтении файла
			fclose(fs);
			files++;
			printf("File %s appended.\r\n", file_src); // содержимое файла добавлено.
			puts("Next file (empty line to quit):"); // Введите имя следующего файла (или пустую строку для завершения)
		}
	}
	printf("Done appending. %d files appended.\r\n", files); // Добавление завершено. Количество добавленных файлов
	rewind(fa);
	printf("%s contents:\r\n", file_app); // Содержание
	while((ch = getc(fa)) != EOF)
		putchar(ch);
	puts("Done displaying."); // Отображение завершено.
	fclose(fa);
	return 0;
}
/*Функция append() выполняет копирование. 
Вместо копирования по одному байту за раз она применяет fread() и fwrite() для копирования по 4096 байтов за один раз void append(FILE *source, FILE *dest)*/
void append(FILE *source, FILE *dest)
{
	size_t bytes;
/*	Обратите внимание, что массив temp имеет статическую продолжительность хранения
	(это значит, что память под него выделяется на этапе компиляции, а не каждый раз, когда вызывается append()) и область видимости в пределах блока 
	(т.е. он является закрытым для данной функции).*/
	static char temp[BUFSIZE]; // Выделить память один раз
	while((bytes = fread(temp, sizeof(char), BUFSIZE, source)) > 0)
		fwrite(temp, sizeof(char), bytes, dest);
/*	Поскольку файл, указанный посредством dest, открыт в режиме добавления, содержимое исходных файлов по очереди добавляется в конец файла dest.*/
}

char *s_gets(char *st, int n)
{
	char *ret_val;
	char *find;
	ret_val = fgets(st, n, stdin);
	if(ret_val)
	{
		find = strchr(st, '\n'); 	// поиск символа новой строки
		if(find)					// если адрес не ялвяется NULL
			*find = '\0';			// поместить туда нулевой символ
		else
			while(getchar() != '\n')
				continue;
	}
	return ret_val;
}
