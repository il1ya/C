/*Произвольный доступ чаще всего применяется с двоичными файлами, записанными с использованием двоичного ввода-вывода, поэтому давайте рассмотрим короткий пример. 
Программа в листинге 13.6 создает файл с числами типа double и затем предоставляет доступ к его содержимому.*/
// Листинг 13.6. Программа randbin.c
/*randbin.c -- Произвольный доступ, двоичный ввода-вывод*/
#include <stdio.h>
#include <stdlib.h>

#define ARSIZE 1000

int main(void)
{
	double numbers[ARSIZE];
	double value;
	const char *file = "numbers.dat";
	int i;
	long pos;
	FILE *iofile;

	// создание набора значений double
	for(i = 0; i < ARSIZE; i++)
		numbers[i] = 100.0 * i + 1.0 / (i + 1);

	//попытка открыть файл
	if((iofile = fopen(file, "wb")) == NULL)
	{
		// stderr зарезервирован для вывода диагностических и отладочных сообщений в текстовом виде.
		fprintf(stderr, "Could not open %s for output.\r\n", file);
		exit(EXIT_FAILURE);
/*		Макрос EXIT_FAILURE используется для возвращения ОС кода о неудачном завершении программы. 
		Этот макрос заменяется на системно-зависимое выражение, которые используется в качестве аргумента для функции exit. 
		Оно должно означать, что работа программы была прекращена преждевременно. Противоположное значение может быть задано макросом EXIT_SUCCESS.*/
	}
	// запись в файл массива в двоичном формате
	fwrite(numbers, sizeof(double), ARSIZE, iofile);
/*Функция fwrite() записывает двоичные данные в файл.*/
/*Когда данные хранятся в файле в представлении, которое применяется в программе, мы говорим, что данные сохранены в форме. 
Никакие преобразования из числовых форм в последовательности символов не производятся. 
Для стандартного ввода-вывода такую услугу предлагают функции fread() и fwrite()*/
	fclose(iofile);
/*Функция fclose() закрывает файл, индентифицируемый (iofile), при необходимости сбрасывая буферы. 
В более ответственной программе вы должны удостовериться, что файл закрыт успешно. 
Функция fclose() возвращает значение 0, если файл был закрыт успешно, и EOF, если нет.*/
	if((iofile = fopen(file, "rb")) == NULL)
	{
		fprintf(stderr, "Could not open %s for random access.\r\n", file);
		exit(EXIT_FAILURE);
	}
	// чтение избранных элементов из файла
	printf("Enter an index in the range 0-%d.\r\n", ARSIZE - 1);
	while(scanf("%d", &i) == 1 && i >= 0 && i < ARSIZE)
	{
		pos = (long) i * sizeof(double); // вычисление смещения
		fseek(iofile, pos, SEEK_SET); // переход в нужную позицию
		fread(&value, sizeof(double), 1, iofile);
		printf("The value there is %f.\r\n", value); // По этому индексу находится значение
		printf("Next index (out of range to quit):\r\n"); // Введите следующий индекс (или значение за пределами диапазона для завершения)
	}
	// завершение
	fclose(iofile);
	puts("Bye!");
	return 0;
}

/*Первым делом программа создает массив и помещает в него ряд значений. 
Затем она создает файл по имени numbers.dat в двоичном режиме и применяет функцию fwrite() для копирования содержимого массива в этот файл. 
64-битовая последовательность для каждого значения double копируется из памяти в файл. 
Вы не сможете прочитать результирующий двоичный файл в текстовом редакторе, т.к. эти значения не транслируются в строки. 
Однако каждое значение хранится в файле точно так же, как оно хранилось в памяти, поэтому точность не теряется. 
Более того, каждое значение занимает 64 бита пространства в файле, благодаря чему легко вычислять местонахождение каждого значения.
Во второй части программы файл открывается для чтения и пользователю предлагается ввести индекс значения. 
Умножение значения индекса на количество байтов, занимаемых типом double, дает позицию в файле. 
Далее в программе вызывается fseek() доя перехода в эту позицию и fread() доя чтения значения из этого места.
Обратите внимание на отсутствие спецификаторов формата. 
Взамен fread() копирует 8 байтов, начиная с заданной позиции, в ячейку памяти, указанную &value. 
После этого программа использует функцию printf() доя отображения value.*/

/*Ниже показаны результаты пробного запуска:
Введите индекс в диапазоне 0-999.
500
По этому индексу находится значение 50000.001996.
Введите следующий индекс (или значение за пределами диапазона для
завершения):
900
По этому индексу находится значение 90000.001110.
Введите следующий индекс (или значение за пределами диапазона для
завершения):
о
По этому индексу находится значение 1.000000.
Введите следующий индекс (или значение за пределами диапазона для
завершения):
-1
Программа завершена.*/