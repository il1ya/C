/*По сравнению с низкоуровневым вводом-выводом стандартный пакет ввода-вывода, помимо переносимости, обладает еще двумя преимуществами. 
Во-первых, в нем доступно множество специализированных функций, которые упрощают решение разнообразных задач, связанных с вводом-выводом. 
Например, функция printf() преобразует различные формы данных в строковый вывод, подходящий для терминалов.
Во-вторых, ввод и вывод являются буферизированнъми. Это значит, что информация передается крупными порциями (обычно по 512 и более байтов), а не по одному байту за раз. 
Например, когда программа читает файл, порция данных считывается в буфер — промежуточную область памяти. 
Такая буферизации существенно увеличивает скорость передачи данных. 
Затем программа может исследовать отдельные байты в этом буфере. Буферизация происходит “за кулисами”, поэтому создается иллюзия посимвольного доступа. 
(Вы также можете буферизировать низкоуровневый ввода-вывода, но бальшую часть работы придется проделать самостоятельно.)
В листинге 13.1 показано, как применять стандартный ввод-вывод для чтения файла и подсчета количества находящихся в нем символов. 
Свойства программы из листинга 13.1 мы обсудим в нескольких последующих разделах. 
(Эта программа использует аргументы командной строки. Если вы работаете в среде Windows, можете после компиляции запустить программу в окне командной строки. 
Если вы имеете дело с Macintosh, проще всего скомпилировать и запустить программу в форме командной строки с использованием Terminal. 
Или же, как объяснялось в главе 11, в XCode посредством меню Products (Продукты) можно предоставить аргументы командной строки для программы, запускаемой из IDE-среды. 
В качестве альтернативы программу можно изменить так, чтобы для получения имени файла вместо аргумента командной строки применялись функции puts() и gets().)*/
// Листинг 13.1. Программа count.c
/*count.c -- использование стандартного ввода-вывода*/
#include <stdio.h>
#include <stdlib.h> // прототип exit()
int main(int argc, char *argv[])
{
	int ch; // место для хранения каждого символа по мере чтения
	FILE *fp; // указатель файла
	unsigned long count = 0;
	if(argc != 2)
	{
		printf("Usage: %s filename\r\n", argv[0]); // Использование имя_файла
		exit(EXIT_FAILURE);
	}
	if((fp = fopen(argv[1], "r")) == NULL)
	{
		printf("Can't open %s\r\n", argv[1]); // не удается открыть
		exit(EXIT_FAILURE);
	}
	while((ch = getc(fp)) != EOF)
	{
		putc(ch, stdout); // то же, что и putchar(ch);
		count++;
	}
	fclose(fp);
	printf("File %s has %lu characters\r\n", argv[1], count); // Файл содержит символов
	return 0;
}
/*Проверка наличия аргумента командной строки
Первым делом программа в листинге 13.1 проверяет значение argc, чтобы выяснить, имеется ли аргумент командной строки. 
Если аргумент отсутствует, программа выводит инструкцию по ее использованию и завершается. 
Строка argv[О] - это имя программы. Явное применение argv[О] вместо имени программы обеспечит автоматическое изменение сообщения об ошибке, 
если вы измените имя исполняемого файла. Такая возможность полезна в средах, подобных Unix, которые разрешают иметь много имен для одного файла. 
Но будьте осторожны - некоторые операционные системы могут не распознавать argv[О], поэтому такой прием не является полностью переносимым.
Функция exit() приводит к прекращению работы программы с закрытием всех открытых файлов. 
Аргумент exit() передается некоторым операционным системам, включая Unix, Linux, Windows и MS-DOS, где он может использоваться другими программами.
Обычное соглашение предусматривает возвращение О при успешном завершении и ненулевого значения в случае ненормального завершения.
Разные выходные значения могут применяться для обозначения различных причин отказа, и это установившаяся практика программирования в средах Unix и DOS.
Тем не менее, не все операционные системы распознают один и тот же диапазон возможных возвращаемых значений. 
Вследствие этого стандарт С устанавливает использование довольно ограниченного минимального диапазона. 
В частности, стандарт требует, чтобы при успешном завершении программы применялось значение О или макрос EXIT_SUCCESS, 
а неудачное завершение указывалось с помощью макроса EXIT_FAILURE. 
Эти макросы, наряду с прототипом exit(), находятся в заголовочном файле stdlib.h.
В рамках ANSI C использование return в первоначальном вызове main() дает тот же результат, что и вызов exit(). 
По этой причине в main () оператор return О; который встречался на протяжении всей книги, эквивалентен следующему оператору:
exit(O);
Однако обратите внимание на определяющую фразу “в первоначальном вызове”.
Если функция main() задействована в рекурсивной программе, то exit() по-прежнему приводит к прекращению ее работы, 
но return передает управление предыдушему уровню рекурсии до тех пор, пока не будет достигнут первоначальный уровень. 
Только после этого return завершает выполнение программы. 
Еще одно отличие между return и exit() состоит в том, что функция exit() прекращает рабогу программы, даже если она вызвана в функции, отличной от main().*/