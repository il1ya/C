/*Следующая программа копирует избранные данные из одного файла в другой. Она открывает два файла одновременно с применением режима "r" для одного и режима "w" для второго. 
Программа (показанная в листинге 13.2) уплотняет содержимое первого файла, грубо остааляя только каждый третий символ. 
В итоге она помещает уплотненный текст во второй файл. Имя второго файла образуется путем дополнения старого имени расширением .red. 
Использование аргментов командной строки, открытие одновременно более одного файла и добавление расширения к имени файла
в общем случае являются довольно практичными приемами. 
Эта конкретная форма уплотнения файла имеет ограниченное применение, но, как вы увидите, такие случаи возникают. 
(Программу несложно модифицировать, чтобы для предоставления имен файлов вместо аргументов командной строки использовались стандартные методы ввода-вывода.)*/

// Листинг 13.2. Программа reducto.c
// reducto.c -- сокращение файлов на две трети!
#include <stdio.h>
#include <stdlib.h> // для exit()
#include <string.h>
int main(int argc, char *argv[])
{
	FILE *in, *out; // Объявление двух указателей на FILE
	int ch;
	char name[LEN]; // хранилище для имени выходного файла
	int count = 0;
	// проверка аргументов командной строки
	if(argc < 2)
	{
		fprintf(stderr, "Usage: %s filename\r\n", argv[0]); // Использование
		exit(EXIT_FAILURE);
	}
	// настройка ввода
	if((in = fopen(argv[1], "r")) == NULL)
	{
		fprintf(stderr, "I couldn't open the file \"%s\"\r\n", argv[1]); // Не удается открыть файл
		exit(EXIT_FAILURE);
	}
	// настройка вывода
	strncpy(name, argv[1], LEN - 5); // копирование имени файла
	name[LEN -5 ] = '\0';
	strcat(name, ".red"); // добавление .red
	if((out = fopen(name, "w")) == NULL)
	{
		// открытие файла для записи
		fprintf(stderr, "Can't create output file.\r\n"); // Не удается создать выходной файл
		exit(3);
	}
	// копирование данных
	while((ch = getc(in)) != EOF)
		if(count++ % 3 == 0)
			putc(ch, out); // выводить каждый третий символ
		// очистка
		if(fclose(in) != 0 || fclose(out) != 0)
			fprintf(stderr, "Error in closing files\r\n");
		return 0;
}

Предположим, что исполняемый файл называется reducto, и мы применяем его к файлу по имени Eddy, который содержит единственную строку:
So even Eddy came oven ready.
Команда имеет такой вид:
reducto eddy
Вывод записывались в файл по имени eddy.red. Программа ничего не выводит на экран, но отображение содержимого eddy.red должно выявить следующее:
Send money
Этот пример иллюстрирует несколько приемов программирования. Давайте рассмотрим некоторые из них.

Функция fprintf() подобна printf() за исключением того, что она требует передачи в первом аргументе указателя файла. 
Мы использовали указатель stderr для отправки сообщений об ошибках в стандартный вывод ошибок; это стандартная практика в С.

Чтобы сконструировать новое имя для выходного файла, в программе применяется функция strncpy() для копирования имени eddy в массив name. 
Аргумент LEN - 5 оставляет место для суффикса .red и завершающего нулевого символа.

Нулевой символ не копируется, если длина строки argv[2] больше LEN - 5, поэтому на всякий случай добавляется нулевой символ. 
После вызова strncpy() первый нулевой символ в name перезаписывается символом точки из .red, когда функция strcat() добавляет эту строку, давая в результате eddy.red. 
Кроме того, в программе предусмотрена проверка, удалось ли открыть файл с именем eddy.red. 
Это особенно важно в определенных средах, где имя файла наподобие strange.с.red может быть недопустимым.
Например, в традиционной системе DOS нельзя добавлять расширение к расширению. 
(Подход, подходящий для MS-DOS, предполагает замену любого существующего расширения вариантом .red, так что удлотненной версией strange.с будет strange.red. 
Можно было бы воспользоваться функцией strchr(), чтобы найти точку в имени, если она есть, и копировать только часть строки до точки.)
В программе имеются два одновременно открытых файла, из-за чего объявлены два указателя на FILE. Обратите внимание, что файлы открываются и закрываются независимо друг от друга. 
Существует предельное количество одновременно открытых файлов, которое зависит от системы и реализации; часто этот предел находится в диапазоне от 10 до 20. 
Одини тот ж е указатель файла можно использовать для разных файлов при условии, что эти файлы не открываются в одно и то ж е время.