вопросы для самоконтроля 474 стр. 813 стр.
Ответы на вопросы для самоконтроля приведены в приложении А.
1. Какая ошибка допущена в представленном объявлении символьной строки?
int main(void)
{
	char name[] = {'Л ', 'у ', 'н ', 'а '};
}
ответ:
нет '\0'
Если вы хотите, чтобы результат бьл строкой, то инициализация должна включать
'\0'. Разумеется, альтернативный синтаксис добавляет нулевой символ автоматически:
char name[] = "Fess";


2. Что выведет следующая программа?

#include <stdio.h>
int main(void)
{
	char note[] = "Увидимся завтра в кафе. ";
	char *ptr;
	ptr = note;
	puts(ptr);
	puts(++ptr);
	note[7] = '\0';
	puts(note);
	puts(++ptr);
	return 0;
}
ответ:
Увидимся завтра в кафе.
видимся завтра в кафе.
Увидимс
идимс

3. Что выведет следующая программа?

#include <stdio.h>
#include <string.h>
int main(void)
}
	char food[] = "Вкусно";
	char *ptr;
	ptr = food + strlen(food);
	while(--ptr >= food)
		puts(ptr);
	return 0;
}
ответ:
о
он
сно
усно
кусно
Вкусно

4. Что выведет следующая программа?

#include <stdio.h>
#include <string.h>
int main(void)
{
	char goldwyn[40] = "огу я смог ";
	char samuel[40] = "За всю дор";
	const char *quote = "осилить лишь часть.";
	strcat(goldwyn, quote);
	strcat(samuel, goldwyn);
	puts(samuel);
	return 0;
}
ответ:
За всю дорогу я смог осилить лишь часть.

5.
Приведенные ниже вопросы позволят попрактиковаться со строками, циклами, указателями и их инкрементированием. 
Предположим, что имеется такое определение функции:
#include <stdio.h>
char *pr(char *str)
{
	char *pc;
	pc = str;
	while(*pc)
		putchar(*pc++);
	do{
		putchar(*--pc);
	}while(pc - str);
	return(pc);
}
Взгляните на следующий вызов функции:
х = pr("Хо Хо Хо!");
а. Что он выводит?
a. "Хо Хо Хо!" "оX оX оX!"
б. Какой тип должна иметь переменная x?
б. тип char
в. Какое значение получает переменная x?
в. Адрес начальной буквы X
г. Что означает выражение *--рс, и чем оно отличается от --*рс?
г. Выражение *--рс означает уменьшение указателя на 1 и использование значения, находящегося по этому адресу. --*рc означает взятие значения, на которое
ссылается указатель рc, и уменьшение этого значения на 1 (например, символ Х становится символом Ф).
д. Что будет выведено, если *--pc заменить выражением *pc--?
д. "Хо Хо Хо! !оХ ох о"
На заметку!
Между символами ! и ! присутствует нулевой символ, но обычно он не оказывает никакого влияния на вывод.
е. Для чего предназначены два выражения проверки в операторах while?
while (*ре) проверяет, не указывает ли рс на нулевой символ (т.е. на конец строки). В выражении используется значение, расположенное по указанному месту.
while (ре - str) проверяет, не указывает ли рc на то же место, что и str(начало строки). В выражении применяются значения самих указателей.
ж. Что произойдет, если функции pr() передать в качестве аргумента пустю строку?
ж. После первой итерации цикла while указатель рc указывает на нулевой символ.
При входе во вторую итерацию цикла он указывает на ячейку памяти, предшествующую нулевому символу (т.е. расположенную непосредственно перед той, на которую указывает str). 
Этот байт интерпретируется как символ и выводится. Затем указатель возвращается к предыдущему байту. 
Условие выхода из цикла (ре == str) никогда не удовлетворяется, и процесс продолжается до тех пор, пока не будет прерван пользователем или системой.

з. Что придется сделать в вызывающей функции, чтобы pr() можно было использовать так, как показано выше?
з. pr() должен быть объявлен в вызывающей программе:
char * pr(char *);

6. Предположим, что имеется следующее объявление:
char sign = '$';
Сколько байтов памяти занимает переменная sign? Значение '$'? Значение "$"?
ответ:
Под символьные переменные отводится один байт, поэтому sign занимает один байт. 
Но символьная константа сохраняется в виде int, т.е. '$' обычно будет использовать 2 или 4 байта; 
тем не менее, для хранения кода '$ 'в действительности будет задействован только один байт из int. 
Строка "$" использует два байта: один для хранения кода символа '$'и еще один для хранения кода символа '\0'.

7. Что выведет следующая программа?
#include <stdio.h>
#include <string.h>
#define M1 "How are ya, sweetie? "
char M2[40] = "Beat the clock.";
char *M3 = "chat";
int main(void)
{
	char words[80];
	printf(M1);
	puts(M1);
	puts(M2);
	puts(M2 + 1);
	strcpy(words, M2);
	strcat(words, "Win a toy.");
	puts(words);
	words[4] = '\0';
	puts(words);
	while(*M3)
		puts(M3++);
	puts(--M3);
	puts(--M3);
	M3 = M1;
	puts(M3);
	return 0;
}
ответ:
How are ya, sweetie? How are ya, sweetie? 
Beat the clock. 
eat the clock.
Beat the clock. Win a toy.
Beat
chat
hat
at
t
t
at
How are ya, sweetie? 

8. Что выведет следующая программа?

#include <stdio.h>
int main(void)
{
	char str1[] = "gawsie";
	char str2[] = "bletonism";
	char *ps;
	int i = 0;
	for(ps = str1; *ps != '\0'; ps++) 
	{
		if(*ps == 'a' || *ps == 'e')
			putchar(*ps);
		else
			(*ps)--;
		putchar(*ps);
	}
	putchar('\n');
	while(str2[i] != '\0') 
	{
		printf("%c", i % 3 ? str2[i] : '*');
		++i;
	}
	return 0;
}
ответ:
faavrhee
*le*on*sm

9. Функцию s_gets(), определенную в этой главе, можно переписать в форме с использованием указателей, а не массивов, чтобы исключить из нее переменную i.
Сделайте это.
Ответ:
#include <stdio.h> // для fgets(), getchar()
char *s_gets(char *st, int n)
{
	char *ret_val;
	ret_val = fgets(st, n, stdin);
	if(ret_val) // т.е. ret_val != NULL
	{
		while(*st != '\n' && *st != '\0')
			i++;
		if(*st == '\n')
			*st = '\0';
		else // требуется наличие words[i] == '\0'
			while(getchar() != '\n')
				continue;
	}
	return ret_val;
}

10. Функция strlen() принимает указатель на строку в качестве аргумента и возвращает длину строки. 
Напишите свою версию этой функции.
ответ:
int strlen(const char *s)
{
	int ct = 0;
	while(*s++) // или while(*s++ != '\0')
		ct++;
	return(ct);
}
11. Функцию s_gets(), определенную в этой главе, можно переписать с использованием функции strchr() вместо цикла while для обнаружения символа новой строки. 
Сделайте это.
#include <stdio.h> // для fgets(), getchar()
#include <string.h> // для strchr();
char *s_gets(char *st, int n)
{
	char *ret_val;
	char *find;
	ret_val = fgets(st, n, stdin);
	if(ret_val)
	{
		find = strchr(st, '\n'); // поиск символа новой строки
		if(find) // если адрес не является NULL
			*find = '\0'; // поместить туда нулевой символ
		else 
			while(getchar() != '\n')
				continue;
	}
	return ret_val;
}
12. Разработайте функцию, которая принимает указатель на строку в качестве аргумента и возвращает указатель на первый символ пробела, расположенный в
указанной позиции внутри строки или после нее. 
Функция должна возвращать нулевой указатель, если пробелы не найдены.
Ответ: Одно из возможных решений выглядит так:
#include <stdio.h> // для определения NULL
char *strblk(char *string)
{
	while(*string != ' ' && *string != '\0')
		string++; // отсановиться на первом пробеле или нулевом символе
	if(*string == '\0')
		return NULL; // NULL - это нулевой указатель
	else
		return string;
}
Второе решение предотвращает изменение строки функцией, но позволяет применять возвращаемое значение для изменения строки. 
Выражение (char *)
string называют "избавлением от const".
#include <stdio.h> // для определения NULL
char *strblk(const char *string)
{
	while(*string != ' ' && *string != '\0')
		string++; // остановиться на первом пробеле или нулевом символе
	if(*string == '\0')
		return NULL; // NULL - это нулевой указатель
	else
		return(char *) string;
}

13. Перепишите программу из листинга 11.21, используя функции из ctype.h для того, чтобы программа распознавала правильный ответ независимо от применения
пользователем прописных или строчных букв.
#include <stdio.h>
#include <ctype.c>
#include <string.h> // объявление strcmp()
#define ANSWER "Grant"
#define SIZE 40
char *s_gets(char *st, int n);
void ToUpper(char *str);
int main(void)
{
	char try[SIZE];
	puts("Who is buried in Grant's tomb?"); // Кто похоронен в могиле Гранта?
	s_gets(try, SIZE);
	ToUpper(try);
	while(strcmp(try, ANSWER) != 0)
	{
		puts("No, that's wrog. Try again."); // Неправильно! Попытайтесь еще раз
		s_gets(try, SIZE);
		ToUpper(try);
	}
	puts("That's right!"); // Теперь правильно!
	return 0;
}
void ToUpper(char *str)
{
	while(*str != '\0')
	{
		*str = toupper(*str);
		str++;
	}
}
char *s_gets(char *st, int n)
{
	char *ret_val;
	int i = 0;
	ret_val = fgets(st, n, stdin);
	if(ret_val)
	{
		while(st[i] != '\n' && st[i] != '\0')
			i++;
		if(st[i] == '\n')
			st[i] == '\0';
		else // требуется наличие words[i] == '\0'
			while(getchar() != '\n')
				continue;
	}
	return ret_val;
}