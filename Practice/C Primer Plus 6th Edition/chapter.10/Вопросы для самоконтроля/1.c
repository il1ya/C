1. Что выведет следующая программа?
#include <stdio.h>
int main(void)
{
int ref[] = {8, 4, 0, 2};
int *ptr;
int index;
for (index = 0, ptr = ref; index < 4; index++, ptr++)
printf("%d %d\n", ref[index], *ptr) ;
return 0;
}

2. Сколько элементов содержит массив ref из вопроса 1?
ответ: 
Массив ref содержит четыре элемента, поскольку таково количество значений
в списке инициализации.

3. Адресом чего является ref из вопроса 1? Что можно сказать о ref + 1? На что указывает ++ref?
ответ: 
Имя массива ref указывает на первый элемент массива — целое число 8.
Выражение ref + 1 указывает на второй элемент — целое число 4. Конструкция
++ref не является допустимым выражением С; ref представляет собой константу, а не переменную.

4. Каковы значения *ptr и *(ptr + 2) в каждом из следующих случаев?
а. 
int *ptr;
int torf[2][2] = { 12, 14, 16);
ptr = torf[0];

б. 
int *ptr;
int fort[2][2] = { {12}, {14, 16} };
ptr = fort[0];
ответ:
ptr указывает на первый элемент, a ptr + 2 — на третий элемент, который будет первым элементом второй строки.
а. 12 и 16.
б. 12 и 14 (согласно скобкам, в первую строку попадает только число 12).

5. Каковы значения **ptr и **(ptr + 1) в каждом из следующих случаев?
а. int (*ptr)[2];
int torf[2][2] = {12, 14, 16);
ptr = torf;

б. int (*ptr)[2];
int fort[2][2] = {{12}, {14,16}};
ptr = fort;

ответ:
ptr указывает на первую строку, a ptr + 1 — на вторую строку; *ptr указывает
на первый элемент в первой строке, a *(ptr + 1) — на первый элемент второй строки.
а. 12 и 16.
б. 12 и 14 (согласно скобкам, в первую строку попадает только число 12).

6. Предположим, что имеется следующее объявление: int grid[30][100];
а. Выразите адрес grid [22][56] одним способом.
б. Выразите адрес grid [22][0] двумя способами.
в. Выразите адрес grid [0][0] тремя способами.

ответ: a. &grid[22][56];
	   б. &grid[22][0]; or &grid[22];
(Второй вариант представляет собой имя одномерного массива, состоящего из 100 элементов, 
	т.е. адрес его первого элемента, которым является grid[22][0])

	   в. &grid[0][0]; or &grid[0]; or (int *)grid;
(Здесь grid[0] — это адрес элемента grid[0][0] типа int, a grid — адрес 100-элементного массива grid[0]. 
Упомянутые два адреса имеют одно и то же значение, но разные типы; приведение делает типы одинаковыми.)

7. Создайте подходящее объявление для каждой из описанных ниже переменных.
а. digits представляет собой массив из 10 значений int.
a. int digits[10] = { ... };
б. rates представляет собой массив из шести значений float.
float rates[6] = { ... };
в. mat представляет собой массив, состоящий из трех массивов, каждый из которых содержит 5 целых чисел.
int mat[3][5] = { ... };
r. psa представляет собой массив, состоящий из 20 указателей на char.
char *psa[20];
Обратите внимание, что приоритет [] выше приоритета *, поэтому при отсутствии скобок сначала применяется описатель массива, 
а затем описатель указателя. Таким образом, это объявление эквивалентно объявлению char * (psa [20]);.
д. pstr представляет собой указатель на массив, состоящий из 20 значений char.
char *pstr[20] = { ... };
В пункте д) нельзя использовать объявление char *pstr [20];. Это сделало бы pstr массивом указателей, а не указателем на массив. 
В частности, pstr указывал бы на одиночное значение char — первый элемент массива, a pstr + 1 указывал бы на следующий байт.
При корректном объявлении pstr представляет собой переменную, а не имя массива, и pstr + 1 указывает на позицию, которая на 20 байт отстоит от начального байта.

8. Решите перечисленные ниже задачи.
а. Объявите массив, состоящий из шести значений типа int, и инициализируйте его значениями 1, 2, 4, 8, 16 и 32.

int array[6] = { 1, 2, 4, 8, 16, 32 };
б. Используйте форму запись с массивом для представления третьего элемента (имеющего значение 4) массива, объявленного в пункте а).

array[2]
в. Предполагая, что действуют правила C99 / C11, объявите массив из 100 значений типа int и инициализируйте его таким образом, чтобы последний элемент
получил значение -1; значения остальных элементов могут быть произвольными.

int array[100] = { [99] = -1 };

г. Предполагая, что действуют правила C99/C11, объявите массив из 100 значений типа int и инициализируйте его так, чтобы элементы 
5, 10, 11, 12 и 3 получили значение 101; значения остальных элементов могут быть произвольными.

int array[100] = { [5] = 101, [10] = 101, [11] = 101, [12] = 101, [3] = 101 };

9. Каков диапазон значений индекса в 10-элементном массиве?
Ответ
От 0 до 9.

10. Предположим, что имеются следующие объявления:
float rootbeer[10], things[10][5], *pf, value = 2.2; int i = 3;
Укажите, какие из приведенных ниже операторов допустимы, а какие - нет:

а. rootbeer[2] = value; да
б. scanf("%f", &rootbeer);
Недопустим; &rootbeer не является значением типа float.
в. rootbeer = value;
Недопустим; rootbeer не является значением типа float.
г. printf("%f", rootbeer);
Недопустим; rootbeer не является значением типа float.
д. things[4][4] = rootbeer[3]; да
е. things [5] = rootbeer;
Недопустим; нельзя присваивать массивы.
ж. pf = value;
Недопустим; value не является адресом.
з. pf = rootbeer; да

11. Объявите массив размерности 800х600 значений типа int.
ответ int array[800][600]

12. Имеются три объявления массивов:
double trots[20]; short clops[10][30]; long shots[5][10][15];
а. Напишите прототип и оператор вызова для традиционной функции типа void, которая обрабатывает массив trots, и для функции С, 
использующей массив переменной длины.
void array(double ar[], int n);
void array1(int n, double ar[n]);
array(trots, 20);
array1(20, trots);
б. Напишите прототип и оператор вызова для традиционной функции типа
void, которая обрабатывает массив clops, и для функции, использующей массив
переменной длины.
в. Напишите прототип и оператор вызова для традиционной функции типа
void, которая обрабатывае
?????????????????????????????????????????????????????????????

13. Имеются два прототипа функций:
void show(const doubl ear[], int n); // n - количество элементов
void show2(const doubl ear2[][3], int n); // n - количество строк
а. Напишите вызов функции, который передает show() составной литерал, 
содержащий значения 8, 3, 9 и 2.
show((int [4]) { 8, 3, 9, 2}, 1);
б. Напишите вызов функции, который передает show2() составной литерал, 
содержащий значения 8, 3 и 9 в первой строке и значения 5, 4 и 1 во второй строке.
show2((int[3][3]) { 8, 3, 9}, {5, 4, 1}, 1);