вопросы для самоконтроля
1. Преобразуйте следующие десятичные значения в двоичную форму:
а. 3
011
б. 13
1101
в. 59
00111011
г. 119
01110111
64+32+16+4+2+1

2. Преобразуйте следующие двоичные значения в десятичную, восьмеричную и шестнадцатеричную форму:
а. 00010101
21 DEC 00010101
025 OCT 000 010 101
762
 OCT = 111 110 010
 111110010 = DEC = 

0x15 HEX 0001 0101

б. 01010101
64+16+4+1
85 DEC 01010101
0125 OCT 001 010 101
0x55 HEX 0101 0101

в. 01001100
76 DEC 01001100
0114 OCT 001 001 100
0x4C HEX 0 0100 1100

г. 10011101
157 DEC 10011101
0235 OCT 010 011 101
0x9D HEX 0 1001 1101

3. Вычислите следующие выражения; предположите, что каждое значение имеет 8 битов:
а. ~3
~00000011 = 3
11111100 = 4+8+16+32+64+128 = 252
б. 3 & 6
00000011 & 00000110 = 00000010 = 2
в. 3 | 6
00000011 | 00000110 = 00000111 = 7
г. 1 | 6
00000001 | 00000110 = 00000111 = 7
д. 3 ^ 6
00000011 ^ 00000110 = 00000101 = 5
е. 7 >> 1
00000111 1>> 00000011 = 3
ж. 7 << 2
00000111 <<2 00011100 = 28

4. Вычислите следующие выражения; предположите, что каждое значение имеет 8 битов:
а. ~0
00000000 ~11111111 = 7 + 8 + 16 + 32 + 64 + 128 = 255
б. !0 (не ложное - это истинно)

в. 2 & 4
00000010 & 00000100 = 00000000 = 0
г. 2 && 4
1(истинно и истинно - это истинно)
д. 2 | 4
00000010 | 00000100 = 00000110 = 6
е. 2 | | 4
00000010 | 00000100 = 00000110; 00000010 | 00000100 = 00000110; 00000110 | 00000110 = 00000110
1(истинно или истинно - это истинно)
ж. 5 << 3
00000101 <<3 = 00101000 = 40

5. Поскольку в ASCII-коде используются только последние 7 битов, иногда желательно маскировать остальные биты. 
Как будет выглядеть подходящая маска в двоичной форме? В десятичной? В восьмеричной? В шестнадцатеричной?

В двоичной форме маска имеет вид 1111111, в десятичной — 127, в восьмеричной 0177, а в шестнадцатеричной — Ox7F.

6. В листинге 15.2 следующий код
while(bits--> 0)
{
	mask |= bitval;
	bitval <<= 1;
}

можно заменить таким фрагментом:
while (bits--> 0)
{
	mask += bitval;
	bitval *= 2;
}

и программа по-прежнему будет работать. 
Означает ли это, что действие *= 2 эквивадентно <<= 1? 
А как насчет |= и +=?

Оба выражения bitval *= 2 и bitval << 1 удваивают текущее значение переменной bitval, поэтому они эквивалентны. 
Однако выражения mask += bitval и mask 1 = bitval оказывают одинаковое влияние, 
только если переменные bitval и mask не имеют ни одного общего установленного бита. 
Например, 2 1 4 равно 6, но этому же значению равен результат выражения 3 1 6.

7. 
а. Компьютер linkerbell содержит в специальном байте информацию, касающуюся оборудования. 
Этот байт может быть прочитан программой, и он содержит следующую информацию:

Биты 	Описание
0-1 	Количество дисководов 1.44 Мбайт
2 		Не используется
3-4 	Количество приводов чтения компакт-дисков
5 		Не используется
6-7 	Количество жестких дисков

Подобно IВМ РС, компьютер Tinkerbell заполняет битовые поля структуры справа налево. 
Создайте шаблон битовых нолей, подходящий для хранения информации.

б. Компьютер Klinkerbell, ближайший клон linkerbell, заполняет битовые ноля структур слева направо. 
Создайте соответствующий шаблон битовых нолей для системы Klinkerbell.

а. struct tb_drives 
{
nsigned int diskdrives : 2;
unsigned int : 1;
unsigned int cdromdrives : 2;
unsigned int : 1;
unsigned int harddrives : 2;
};
б. struct kb_drives 
{
unsigned int harddrives : 2;
unsigned int : 1;
unsigned int cdromdrives : 2;
unsigned int : 1;
unsigned int diskdrives : 2;
};